/*!
 * Bootstrap v5.0.0-beta1 (https://getbootstrap.com/)
 * Copyright 2011-2020 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 */
!(function (t, e) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? (module.exports = e())
    : typeof define === 'function' && define.amd
      ? define(e)
      : ((t =
        typeof globalThis !== 'undefined' ? globalThis : t || self).bootstrap =
        e())
})(this, function () {
  'use strict'
  function t (t, e) {
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      (i.enumerable = i.enumerable || !1),
      (i.configurable = !0),
      'value' in i && (i.writable = !0),
      Object.defineProperty(t, i.key, i)
    }
  }
  function e (e, n, i) {
    return n && t(e.prototype, n), i && t(e, i), e
  }
  function n () {
    return (n =
      Object.assign ||
      function (t) {
        for (let e = 1; e < arguments.length; e++) {
          const n = arguments[e]
          for (const i in n) {
            Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
          }
        }
        return t
      }).apply(this, arguments)
  }
  function i (t, e) {
    (t.prototype = Object.create(e.prototype)),
    (t.prototype.constructor = t),
    (t.__proto__ = e)
  }
  let o
  let r
  const s = function (t) {
    do {
      t += Math.floor(1e6 * Math.random())
    } while (document.getElementById(t))
    return t
  }
  const a = function (t) {
    let e = t.getAttribute('data-bs-target')
    if (!e || e === '#') {
      const n = t.getAttribute('href')
      e = n && n !== '#' ? n.trim() : null
    }
    return e
  }
  const l = function (t) {
    const e = a(t)
    return e && document.querySelector(e) ? e : null
  }
  const c = function (t) {
    const e = a(t)
    return e ? document.querySelector(e) : null
  }
  const u = function (t) {
    if (!t) return 0
    const e = window.getComputedStyle(t)
    let n = e.transitionDuration
    let i = e.transitionDelay
    const o = Number.parseFloat(n)
    const r = Number.parseFloat(i)
    return o || r
      ? ((n = n.split(',')[0]),
        (i = i.split(',')[0]),
        1e3 * (Number.parseFloat(n) + Number.parseFloat(i)))
      : 0
  }
  const f = function (t) {
    t.dispatchEvent(new Event('transitionend'))
  }
  const d = function (t) {
    return (t[0] || t).nodeType
  }
  const h = function (t, e) {
    let n = !1
    const i = e + 5
    t.addEventListener('transitionend', function e () {
      (n = !0), t.removeEventListener('transitionend', e)
    }),
    setTimeout(function () {
      n || f(t)
    }, i)
  }
  const p = function (t, e, n) {
    Object.keys(n).forEach(function (i) {
      let o
      const r = n[i]
      const s = e[i]
      const a =
        s && d(s)
          ? 'element'
          : (o = s) == null
              ? '' + o
              : {}.toString
                  .call(o)
                  .match(/\s([a-z]+)/i)[1]
                  .toLowerCase()
      if (!new RegExp(r).test(a)) {
        throw new Error(
          t.toUpperCase() +
            ': Option "' +
            i +
            '" provided type "' +
            a +
            '" but expected type "' +
            r +
            '".'
        )
      }
    })
  }
  const g = function (t) {
    if (!t) return !1
    if (t.style && t.parentNode && t.parentNode.style) {
      const e = getComputedStyle(t)
      const n = getComputedStyle(t.parentNode)
      return (
        e.display !== 'none' &&
        n.display !== 'none' &&
        e.visibility !== 'hidden'
      )
    }
    return !1
  }
  const m = function () {
    return function () {}
  }
  const v = function (t) {
    return t.offsetHeight
  }
  const _ = function () {
    const t = window.jQuery
    return t && !document.body.hasAttribute('data-bs-no-jquery') ? t : null
  }
  const b = function (t) {
    document.readyState === 'loading'
      ? document.addEventListener('DOMContentLoaded', t)
      : t()
  }
  const y = document.documentElement.dir === 'rtl'
  const w =
    ((o = {}),
    (r = 1),
    {
      set: function (t, e, n) {
        void 0 === t.bsKey && ((t.bsKey = { key: e, id: r }), r++),
        (o[t.bsKey.id] = n)
      },
      get: function (t, e) {
        if (!t || void 0 === t.bsKey) return null
        const n = t.bsKey
        return n.key === e ? o[n.id] : null
      },
      delete: function (t, e) {
        if (void 0 !== t.bsKey) {
          const n = t.bsKey
          n.key === e && (delete o[n.id], delete t.bsKey)
        }
      }
    })
  const E = function (t, e, n) {
    w.set(t, e, n)
  }
  const T = function (t, e) {
    return w.get(t, e)
  }
  const k = function (t, e) {
    w.delete(t, e)
  }
  const O = /[^.]*(?=\..*)\.|.*/
  const L = /\..*/
  const A = /::\d+$/
  const C = {}
  let D = 1
  const x = { mouseenter: 'mouseover', mouseleave: 'mouseout' }
  const S = new Set([
    'click',
    'dblclick',
    'mouseup',
    'mousedown',
    'contextmenu',
    'mousewheel',
    'DOMMouseScroll',
    'mouseover',
    'mouseout',
    'mousemove',
    'selectstart',
    'selectend',
    'keydown',
    'keypress',
    'keyup',
    'orientationchange',
    'touchstart',
    'touchmove',
    'touchend',
    'touchcancel',
    'pointerdown',
    'pointermove',
    'pointerup',
    'pointerleave',
    'pointercancel',
    'gesturestart',
    'gesturechange',
    'gestureend',
    'focus',
    'blur',
    'change',
    'reset',
    'select',
    'submit',
    'focusin',
    'focusout',
    'load',
    'unload',
    'beforeunload',
    'resize',
    'move',
    'DOMContentLoaded',
    'readystatechange',
    'error',
    'abort',
    'scroll'
  ])
  function j (t, e) {
    return (e && e + '::' + D++) || t.uidEvent || D++
  }
  function N (t) {
    const e = j(t)
    return (t.uidEvent = e), (C[e] = C[e] || {}), C[e]
  }
  function I (t, e, n) {
    void 0 === n && (n = null)
    for (let i = Object.keys(t), o = 0, r = i.length; o < r; o++) {
      const s = t[i[o]]
      if (s.originalHandler === e && s.delegationSelector === n) return s
    }
    return null
  }
  function P (t, e, n) {
    const i = typeof e === 'string'
    const o = i ? n : e
    let r = t.replace(L, '')
    const s = x[r]
    return s && (r = s), S.has(r) || (r = t), [i, o, r]
  }
  function M (t, e, n, i, o) {
    if (typeof e === 'string' && t) {
      n || ((n = i), (i = null))
      const r = P(e, n, i)
      const s = r[0]
      const a = r[1]
      const l = r[2]
      const c = N(t)
      const u = c[l] || (c[l] = {})
      const f = I(u, a, s ? n : null)
      if (f) f.oneOff = f.oneOff && o
      else {
        const d = j(a, e.replace(O, ''))
        const h = s
          ? (function (t, e, n) {
              return function i (o) {
                for (
                  let r = t.querySelectorAll(e), s = o.target;
                  s && s !== this;
                  s = s.parentNode
                ) {
                  for (let a = r.length; a--;) {
                    if (r[a] === s) {
                      return (
                        (o.delegateTarget = s),
                        i.oneOff && H.off(t, o.type, n),
                        n.apply(s, [o])
                      )
                    }
                  }
                }
                return null
              }
            })(t, n, i)
          : (function (t, e) {
              return function n (i) {
                return (
                  (i.delegateTarget = t),
                  n.oneOff && H.off(t, i.type, e),
                  e.apply(t, [i])
                )
              }
            })(t, n);
        (h.delegationSelector = s ? n : null),
        (h.originalHandler = a),
        (h.oneOff = o),
        (h.uidEvent = d),
        (u[d] = h),
        t.addEventListener(l, h, s)
      }
    }
  }
  function B (t, e, n, i, o) {
    const r = I(e[n], i, o)
    r && (t.removeEventListener(n, r, Boolean(o)), delete e[n][r.uidEvent])
  }
  var H = {
    on: function (t, e, n, i) {
      M(t, e, n, i, !1)
    },
    one: function (t, e, n, i) {
      M(t, e, n, i, !0)
    },
    off: function (t, e, n, i) {
      if (typeof e === 'string' && t) {
        const o = P(e, n, i)
        const r = o[0]
        const s = o[1]
        const a = o[2]
        const l = a !== e
        const c = N(t)
        const u = e.startsWith('.')
        if (void 0 === s) {
          u &&
            Object.keys(c).forEach(function (n) {
              !(function (t, e, n, i) {
                const o = e[n] || {}
                Object.keys(o).forEach(function (r) {
                  if (r.includes(i)) {
                    const s = o[r]
                    B(t, e, n, s.originalHandler, s.delegationSelector)
                  }
                })
              })(t, c, n, e.slice(1))
            })
          const f = c[a] || {}
          Object.keys(f).forEach(function (n) {
            const i = n.replace(A, '')
            if (!l || e.includes(i)) {
              const o = f[n]
              B(t, c, a, o.originalHandler, o.delegationSelector)
            }
          })
        } else {
          if (!c || !c[a]) return
          B(t, c, a, s, r ? n : null)
        }
      }
    },
    trigger: function (t, e, n) {
      if (typeof e !== 'string' || !t) return null
      let i
      const o = _()
      const r = e.replace(L, '')
      const s = e !== r
      const a = S.has(r)
      let l = !0
      let c = !0
      let u = !1
      let f = null
      return (
        s &&
          o &&
          ((i = o.Event(e, n)),
          o(t).trigger(i),
          (l = !i.isPropagationStopped()),
          (c = !i.isImmediatePropagationStopped()),
          (u = i.isDefaultPrevented())),
        a
          ? (f = document.createEvent('HTMLEvents')).initEvent(r, l, !0)
          : (f = new CustomEvent(e, { bubbles: l, cancelable: !0 })),
        void 0 !== n &&
          Object.keys(n).forEach(function (t) {
            Object.defineProperty(f, t, {
              get: function () {
                return n[t]
              }
            })
          }),
        u && f.preventDefault(),
        c && t.dispatchEvent(f),
        f.defaultPrevented && void 0 !== i && i.preventDefault(),
        f
      )
    }
  }
  const R = (function () {
    function t (t) {
      t && ((this._element = t), E(t, this.constructor.DATA_KEY, this))
    }
    return (
      (t.prototype.dispose = function () {
        k(this._element, this.constructor.DATA_KEY), (this._element = null)
      }),
      (t.getInstance = function (t) {
        return T(t, this.DATA_KEY)
      }),
      e(t, null, [
        {
          key: 'VERSION',
          get: function () {
            return '5.0.0-beta1'
          }
        }
      ]),
      t
    )
  })()
  const W = 'alert'
  const K = (function (t) {
    function n () {
      return t.apply(this, arguments) || this
    }
    i(n, t)
    const o = n.prototype
    return (
      (o.close = function (t) {
        const e = t ? this._getRootElement(t) : this._element
        const n = this._triggerCloseEvent(e)
        n === null || n.defaultPrevented || this._removeElement(e)
      }),
      (o._getRootElement = function (t) {
        return c(t) || t.closest('.alert')
      }),
      (o._triggerCloseEvent = function (t) {
        return H.trigger(t, 'close.bs.alert')
      }),
      (o._removeElement = function (t) {
        const e = this
        if ((t.classList.remove('show'), t.classList.contains('fade'))) {
          const n = u(t)
          H.one(t, 'transitionend', function () {
            return e._destroyElement(t)
          }),
          h(t, n)
        } else this._destroyElement(t)
      }),
      (o._destroyElement = function (t) {
        t.parentNode && t.parentNode.removeChild(t),
        H.trigger(t, 'closed.bs.alert')
      }),
      (n.jQueryInterface = function (t) {
        return this.each(function () {
          let e = T(this, 'bs.alert')
          e || (e = new n(this)), t === 'close' && e[t](this)
        })
      }),
      (n.handleDismiss = function (t) {
        return function (e) {
          e && e.preventDefault(), t.close(this)
        }
      }),
      e(n, null, [
        {
          key: 'DATA_KEY',
          get: function () {
            return 'bs.alert'
          }
        }
      ]),
      n
    )
  })(R)
  H.on(
    document,
    'click.bs.alert.data-api',
    '[data-bs-dismiss="alert"]',
    K.handleDismiss(new K())
  ),
  b(function () {
    const t = _()
    if (t) {
      const e = t.fn[W];
      (t.fn[W] = K.jQueryInterface),
      (t.fn[W].Constructor = K),
      (t.fn[W].noConflict = function () {
        return (t.fn[W] = e), K.jQueryInterface
      })
    }
  })
  const Q = (function (t) {
    function n () {
      return t.apply(this, arguments) || this
    }
    return (
      i(n, t),
      (n.prototype.toggle = function () {
        this._element.setAttribute(
          'aria-pressed',
          this._element.classList.toggle('active')
        )
      }),
      (n.jQueryInterface = function (t) {
        return this.each(function () {
          let e = T(this, 'bs.button')
          e || (e = new n(this)), t === 'toggle' && e[t]()
        })
      }),
      e(n, null, [
        {
          key: 'DATA_KEY',
          get: function () {
            return 'bs.button'
          }
        }
      ]),
      n
    )
  })(R)
  function U (t) {
    return (
      t === 'true' ||
      (t !== 'false' &&
        (t === Number(t).toString()
          ? Number(t)
          : t === '' || t === 'null'
            ? null
            : t))
    )
  }
  function F (t) {
    return t.replace(/[A-Z]/g, function (t) {
      return '-' + t.toLowerCase()
    })
  }
  H.on(
    document,
    'click.bs.button.data-api',
    '[data-bs-toggle="button"]',
    function (t) {
      t.preventDefault()
      const e = t.target.closest('[data-bs-toggle="button"]')
      let n = T(e, 'bs.button')
      n || (n = new Q(e)), n.toggle()
    }
  ),
  b(function () {
    const t = _()
    if (t) {
      const e = t.fn.button;
      (t.fn.button = Q.jQueryInterface),
      (t.fn.button.Constructor = Q),
      (t.fn.button.noConflict = function () {
        return (t.fn.button = e), Q.jQueryInterface
      })
    }
  })
  const Y = {
    setDataAttribute: function (t, e, n) {
      t.setAttribute('data-bs-' + F(e), n)
    },
    removeDataAttribute: function (t, e) {
      t.removeAttribute('data-bs-' + F(e))
    },
    getDataAttributes: function (t) {
      if (!t) return {}
      const e = {}
      return (
        Object.keys(t.dataset)
          .filter(function (t) {
            return t.startsWith('bs')
          })
          .forEach(function (n) {
            let i = n.replace(/^bs/, '');
            (i = i.charAt(0).toLowerCase() + i.slice(1, i.length)),
            (e[i] = U(t.dataset[n]))
          }),
        e
      )
    },
    getDataAttribute: function (t, e) {
      return U(t.getAttribute('data-bs-' + F(e)))
    },
    offset: function (t) {
      const e = t.getBoundingClientRect()
      return {
        top: e.top + document.body.scrollTop,
        left: e.left + document.body.scrollLeft
      }
    },
    position: function (t) {
      return { top: t.offsetTop, left: t.offsetLeft }
    }
  }
  const q = {
    matches: function (t, e) {
      return t.matches(e)
    },
    find: function (t, e) {
      let n
      return (
        void 0 === e && (e = document.documentElement),
        (n = []).concat.apply(n, Element.prototype.querySelectorAll.call(e, t))
      )
    },
    findOne: function (t, e) {
      return (
        void 0 === e && (e = document.documentElement),
        Element.prototype.querySelector.call(e, t)
      )
    },
    children: function (t, e) {
      let n
      const i = (n = []).concat.apply(n, t.children)
      return i.filter(function (t) {
        return t.matches(e)
      })
    },
    parents: function (t, e) {
      for (
        var n = [], i = t.parentNode;
        i && i.nodeType === Node.ELEMENT_NODE && i.nodeType !== 3;

      ) {
        this.matches(i, e) && n.push(i), (i = i.parentNode)
      }
      return n
    },
    prev: function (t, e) {
      for (let n = t.previousElementSibling; n;) {
        if (n.matches(e)) return [n]
        n = n.previousElementSibling
      }
      return []
    },
    next: function (t, e) {
      for (let n = t.nextElementSibling; n;) {
        if (this.matches(n, e)) return [n]
        n = n.nextElementSibling
      }
      return []
    }
  }
  const z = 'carousel'
  const V = '.bs.carousel'
  const X = {
    interval: 5e3,
    keyboard: !0,
    slide: !1,
    pause: 'hover',
    wrap: !0,
    touch: !0
  }
  const $ = {
    interval: '(number|boolean)',
    keyboard: 'boolean',
    slide: '(boolean|string)',
    pause: '(string|boolean)',
    wrap: 'boolean',
    touch: 'boolean'
  }
  const G = { TOUCH: 'touch', PEN: 'pen' }
  const Z = (function (t) {
    function o (e, n) {
      let i
      return (
        ((i = t.call(this, e) || this)._items = null),
        (i._interval = null),
        (i._activeElement = null),
        (i._isPaused = !1),
        (i._isSliding = !1),
        (i.touchTimeout = null),
        (i.touchStartX = 0),
        (i.touchDeltaX = 0),
        (i._config = i._getConfig(n)),
        (i._indicatorsElement = q.findOne('.carousel-indicators', i._element)),
        (i._touchSupported =
          'ontouchstart' in document.documentElement ||
          navigator.maxTouchPoints > 0),
        (i._pointerEvent = Boolean(window.PointerEvent)),
        i._addEventListeners(),
        i
      )
    }
    i(o, t)
    const r = o.prototype
    return (
      (r.next = function () {
        this._isSliding || this._slide('next')
      }),
      (r.nextWhenVisible = function () {
        !document.hidden && g(this._element) && this.next()
      }),
      (r.prev = function () {
        this._isSliding || this._slide('prev')
      }),
      (r.pause = function (t) {
        t || (this._isPaused = !0),
        q.findOne(
          '.carousel-item-next, .carousel-item-prev',
          this._element
        ) && (f(this._element), this.cycle(!0)),
        clearInterval(this._interval),
        (this._interval = null)
      }),
      (r.cycle = function (t) {
        t || (this._isPaused = !1),
        this._interval &&
            (clearInterval(this._interval), (this._interval = null)),
        this._config &&
            this._config.interval &&
            !this._isPaused &&
            (this._updateInterval(),
            (this._interval = setInterval(
              (document.visibilityState
                ? this.nextWhenVisible
                : this.next
              ).bind(this),
              this._config.interval
            )))
      }),
      (r.to = function (t) {
        const e = this
        this._activeElement = q.findOne('.active.carousel-item', this._element)
        const n = this._getItemIndex(this._activeElement)
        if (!(t > this._items.length - 1 || t < 0)) {
          if (this._isSliding) {
            H.one(this._element, 'slid.bs.carousel', function () {
              return e.to(t)
            })
          } else {
            if (n === t) return this.pause(), void this.cycle()
            const i = t > n ? 'next' : 'prev'
            this._slide(i, this._items[t])
          }
        }
      }),
      (r.dispose = function () {
        t.prototype.dispose.call(this),
        H.off(this._element, V),
        (this._items = null),
        (this._config = null),
        (this._interval = null),
        (this._isPaused = null),
        (this._isSliding = null),
        (this._activeElement = null),
        (this._indicatorsElement = null)
      }),
      (r._getConfig = function (t) {
        return (t = n({}, X, t)), p(z, t, $), t
      }),
      (r._handleSwipe = function () {
        const t = Math.abs(this.touchDeltaX)
        if (!(t <= 40)) {
          const e = t / this.touchDeltaX;
          (this.touchDeltaX = 0), e > 0 && this.prev(), e < 0 && this.next()
        }
      }),
      (r._addEventListeners = function () {
        const t = this
        this._config.keyboard &&
          H.on(this._element, 'keydown.bs.carousel', function (e) {
            return t._keydown(e)
          }),
        this._config.pause === 'hover' &&
            (H.on(this._element, 'mouseenter.bs.carousel', function (e) {
              return t.pause(e)
            }),
            H.on(this._element, 'mouseleave.bs.carousel', function (e) {
              return t.cycle(e)
            })),
        this._config.touch &&
            this._touchSupported &&
            this._addTouchEventListeners()
      }),
      (r._addTouchEventListeners = function () {
        const t = this
        const e = function (e) {
          t._pointerEvent && G[e.pointerType.toUpperCase()]
            ? (t.touchStartX = e.clientX)
            : t._pointerEvent || (t.touchStartX = e.touches[0].clientX)
        }
        const n = function (e) {
          t._pointerEvent &&
            G[e.pointerType.toUpperCase()] &&
            (t.touchDeltaX = e.clientX - t.touchStartX),
          t._handleSwipe(),
          t._config.pause === 'hover' &&
              (t.pause(),
              t.touchTimeout && clearTimeout(t.touchTimeout),
              (t.touchTimeout = setTimeout(function (e) {
                return t.cycle(e)
              }, 500 + t._config.interval)))
        }
        q.find('.carousel-item img', this._element).forEach(function (t) {
          H.on(t, 'dragstart.bs.carousel', function (t) {
            return t.preventDefault()
          })
        }),
        this._pointerEvent
          ? (H.on(this._element, 'pointerdown.bs.carousel', function (t) {
              return e(t)
            }),
            H.on(this._element, 'pointerup.bs.carousel', function (t) {
              return n(t)
            }),
            this._element.classList.add('pointer-event'))
          : (H.on(this._element, 'touchstart.bs.carousel', function (t) {
              return e(t)
            }),
            H.on(this._element, 'touchmove.bs.carousel', function (e) {
              return (function (e) {
                e.touches && e.touches.length > 1
                  ? (t.touchDeltaX = 0)
                  : (t.touchDeltaX = e.touches[0].clientX - t.touchStartX)
              })(e)
            }),
            H.on(this._element, 'touchend.bs.carousel', function (t) {
              return n(t)
            }))
      }),
      (r._keydown = function (t) {
        if (!/input|textarea/i.test(t.target.tagName)) {
          switch (t.key) {
            case 'ArrowLeft':
              t.preventDefault(), this.prev()
              break
            case 'ArrowRight':
              t.preventDefault(), this.next()
          }
        }
      }),
      (r._getItemIndex = function (t) {
        return (
          (this._items =
            t && t.parentNode ? q.find('.carousel-item', t.parentNode) : []),
          this._items.indexOf(t)
        )
      }),
      (r._getItemByDirection = function (t, e) {
        const n = t === 'next'
        const i = t === 'prev'
        const o = this._getItemIndex(e)
        const r = this._items.length - 1
        if (((i && o === 0) || (n && o === r)) && !this._config.wrap) {
          return e
        }
        const s = (o + (t === 'prev' ? -1 : 1)) % this._items.length
        return s === -1 ? this._items[this._items.length - 1] : this._items[s]
      }),
      (r._triggerSlideEvent = function (t, e) {
        const n = this._getItemIndex(t)
        const i = this._getItemIndex(
          q.findOne('.active.carousel-item', this._element)
        )
        return H.trigger(this._element, 'slide.bs.carousel', {
          relatedTarget: t,
          direction: e,
          from: i,
          to: n
        })
      }),
      (r._setActiveIndicatorElement = function (t) {
        if (this._indicatorsElement) {
          for (
            let e = q.find('.active', this._indicatorsElement), n = 0;
            n < e.length;
            n++
          ) {
            e[n].classList.remove('active')
          }
          const i = this._indicatorsElement.children[this._getItemIndex(t)]
          i && i.classList.add('active')
        }
      }),
      (r._updateInterval = function () {
        const t =
          this._activeElement ||
          q.findOne('.active.carousel-item', this._element)
        if (t) {
          const e = Number.parseInt(t.getAttribute('data-bs-interval'), 10)
          e
            ? ((this._config.defaultInterval =
                this._config.defaultInterval || this._config.interval),
              (this._config.interval = e))
            : (this._config.interval =
                this._config.defaultInterval || this._config.interval)
        }
      }),
      (r._slide = function (t, e) {
        let n
        let i
        let o
        const r = this
        const s = q.findOne('.active.carousel-item', this._element)
        const a = this._getItemIndex(s)
        const l = e || (s && this._getItemByDirection(t, s))
        const c = this._getItemIndex(l)
        const f = Boolean(this._interval)
        if (
          (t === 'next'
            ? ((n = 'carousel-item-start'),
              (i = 'carousel-item-next'),
              (o = 'left'))
            : ((n = 'carousel-item-end'),
              (i = 'carousel-item-prev'),
              (o = 'right')),
          l && l.classList.contains('active'))
        ) {
          this._isSliding = !1
        } else if (!this._triggerSlideEvent(l, o).defaultPrevented && s && l) {
          if (
            ((this._isSliding = !0),
            f && this.pause(),
            this._setActiveIndicatorElement(l),
            (this._activeElement = l),
            this._element.classList.contains('slide'))
          ) {
            l.classList.add(i), v(l), s.classList.add(n), l.classList.add(n)
            const d = u(s)
            H.one(s, 'transitionend', function () {
              l.classList.remove(n, i),
              l.classList.add('active'),
              s.classList.remove('active', i, n),
              (r._isSliding = !1),
              setTimeout(function () {
                H.trigger(r._element, 'slid.bs.carousel', {
                  relatedTarget: l,
                  direction: o,
                  from: a,
                  to: c
                })
              }, 0)
            }),
            h(s, d)
          } else {
            s.classList.remove('active'),
            l.classList.add('active'),
            (this._isSliding = !1),
            H.trigger(this._element, 'slid.bs.carousel', {
              relatedTarget: l,
              direction: o,
              from: a,
              to: c
            })
          }
          f && this.cycle()
        }
      }),
      (o.carouselInterface = function (t, e) {
        let i = T(t, 'bs.carousel')
        let r = n({}, X, Y.getDataAttributes(t))
        typeof e === 'object' && (r = n({}, r, e))
        const s = typeof e === 'string' ? e : r.slide
        if ((i || (i = new o(t, r)), typeof e === 'number')) i.to(e)
        else if (typeof s === 'string') {
          if (void 0 === i[s]) {
            throw new TypeError('No method named "' + s + '"')
          }
          i[s]()
        } else r.interval && r.ride && (i.pause(), i.cycle())
      }),
      (o.jQueryInterface = function (t) {
        return this.each(function () {
          o.carouselInterface(this, t)
        })
      }),
      (o.dataApiClickHandler = function (t) {
        const e = c(this)
        if (e && e.classList.contains('carousel')) {
          const i = n({}, Y.getDataAttributes(e), Y.getDataAttributes(this))
          const r = this.getAttribute('data-bs-slide-to')
          r && (i.interval = !1),
          o.carouselInterface(e, i),
          r && T(e, 'bs.carousel').to(r),
          t.preventDefault()
        }
      }),
      e(o, null, [
        {
          key: 'Default',
          get: function () {
            return X
          }
        },
        {
          key: 'DATA_KEY',
          get: function () {
            return 'bs.carousel'
          }
        }
      ]),
      o
    )
  })(R)
  H.on(
    document,
    'click.bs.carousel.data-api',
    '[data-bs-slide], [data-bs-slide-to]',
    Z.dataApiClickHandler
  ),
  H.on(window, 'load.bs.carousel.data-api', function () {
    for (
      let t = q.find('[data-bs-ride="carousel"]'), e = 0, n = t.length;
      e < n;
      e++
    ) {
      Z.carouselInterface(t[e], T(t[e], 'bs.carousel'))
    }
  }),
  b(function () {
    const t = _()
    if (t) {
      const e = t.fn[z];
      (t.fn[z] = Z.jQueryInterface),
      (t.fn[z].Constructor = Z),
      (t.fn[z].noConflict = function () {
        return (t.fn[z] = e), Z.jQueryInterface
      })
    }
  })
  const J = 'collapse'
  const tt = { toggle: !0, parent: '' }
  const et = { toggle: 'boolean', parent: '(string|element)' }
  const nt = (function (t) {
    function o (e, n) {
      let i;
      ((i = t.call(this, e) || this)._isTransitioning = !1),
      (i._config = i._getConfig(n)),
      (i._triggerArray = q.find(
        '[data-bs-toggle="collapse"][href="#' +
            e.id +
            '"],[data-bs-toggle="collapse"][data-bs-target="#' +
            e.id +
            '"]'
      ))
      for (
        let o = q.find('[data-bs-toggle="collapse"]'), r = 0, s = o.length;
        r < s;
        r++
      ) {
        const a = o[r]
        const c = l(a)
        const u = q.find(c).filter(function (t) {
          return t === e
        })
        c !== null && u.length && ((i._selector = c), i._triggerArray.push(a))
      }
      return (
        (i._parent = i._config.parent ? i._getParent() : null),
        i._config.parent ||
          i._addAriaAndCollapsedClass(i._element, i._triggerArray),
        i._config.toggle && i.toggle(),
        i
      )
    }
    i(o, t)
    const r = o.prototype
    return (
      (r.toggle = function () {
        this._element.classList.contains('show') ? this.hide() : this.show()
      }),
      (r.show = function () {
        const t = this
        if (
          !this._isTransitioning &&
          !this._element.classList.contains('show')
        ) {
          let e, n
          this._parent &&
            (e = q
              .find('.show, .collapsing', this._parent)
              .filter(function (e) {
                return typeof t._config.parent === 'string'
                  ? e.getAttribute('data-bs-parent') === t._config.parent
                  : e.classList.contains('collapse')
              })).length === 0 &&
            (e = null)
          const i = q.findOne(this._selector)
          if (e) {
            const r = e.find(function (t) {
              return i !== t
            })
            if ((n = r ? T(r, 'bs.collapse') : null) && n._isTransitioning) {
              return
            }
          }
          if (!H.trigger(this._element, 'show.bs.collapse').defaultPrevented) {
            e &&
              e.forEach(function (t) {
                i !== t && o.collapseInterface(t, 'hide'),
                n || E(t, 'bs.collapse', null)
              })
            const s = this._getDimension()
            this._element.classList.remove('collapse'),
            this._element.classList.add('collapsing'),
            (this._element.style[s] = 0),
            this._triggerArray.length &&
                this._triggerArray.forEach(function (t) {
                  t.classList.remove('collapsed'),
                  t.setAttribute('aria-expanded', !0)
                }),
            this.setTransitioning(!0)
            const a = 'scroll' + (s[0].toUpperCase() + s.slice(1))
            const l = u(this._element)
            H.one(this._element, 'transitionend', function () {
              t._element.classList.remove('collapsing'),
              t._element.classList.add('collapse', 'show'),
              (t._element.style[s] = ''),
              t.setTransitioning(!1),
              H.trigger(t._element, 'shown.bs.collapse')
            }),
            h(this._element, l),
            (this._element.style[s] = this._element[a] + 'px')
          }
        }
      }),
      (r.hide = function () {
        const t = this
        if (
          !this._isTransitioning &&
          this._element.classList.contains('show') &&
          !H.trigger(this._element, 'hide.bs.collapse').defaultPrevented
        ) {
          const e = this._getDimension();
          (this._element.style[e] =
            this._element.getBoundingClientRect()[e] + 'px'),
          v(this._element),
          this._element.classList.add('collapsing'),
          this._element.classList.remove('collapse', 'show')
          const n = this._triggerArray.length
          if (n > 0) {
            for (let i = 0; i < n; i++) {
              const o = this._triggerArray[i]
              const r = c(o)
              r &&
                !r.classList.contains('show') &&
                (o.classList.add('collapsed'),
                o.setAttribute('aria-expanded', !1))
            }
          }
          this.setTransitioning(!0)
          this._element.style[e] = ''
          const s = u(this._element)
          H.one(this._element, 'transitionend', function () {
            t.setTransitioning(!1),
            t._element.classList.remove('collapsing'),
            t._element.classList.add('collapse'),
            H.trigger(t._element, 'hidden.bs.collapse')
          }),
          h(this._element, s)
        }
      }),
      (r.setTransitioning = function (t) {
        this._isTransitioning = t
      }),
      (r.dispose = function () {
        t.prototype.dispose.call(this),
        (this._config = null),
        (this._parent = null),
        (this._triggerArray = null),
        (this._isTransitioning = null)
      }),
      (r._getConfig = function (t) {
        return ((t = n({}, tt, t)).toggle = Boolean(t.toggle)), p(J, t, et), t
      }),
      (r._getDimension = function () {
        return this._element.classList.contains('width') ? 'width' : 'height'
      }),
      (r._getParent = function () {
        const t = this
        let e = this._config.parent
        d(e)
          ? (void 0 === e.jquery && void 0 === e[0]) || (e = e[0])
          : (e = q.findOne(e))
        const n = '[data-bs-toggle="collapse"][data-bs-parent="' + e + '"]'
        return (
          q.find(n, e).forEach(function (e) {
            const n = c(e)
            t._addAriaAndCollapsedClass(n, [e])
          }),
          e
        )
      }),
      (r._addAriaAndCollapsedClass = function (t, e) {
        if (t && e.length) {
          const n = t.classList.contains('show')
          e.forEach(function (t) {
            n ? t.classList.remove('collapsed') : t.classList.add('collapsed'),
            t.setAttribute('aria-expanded', n)
          })
        }
      }),
      (o.collapseInterface = function (t, e) {
        let i = T(t, 'bs.collapse')
        const r = n(
          {},
          tt,
          Y.getDataAttributes(t),
          typeof e === 'object' && e ? e : {}
        )
        if (
          (!i &&
            r.toggle &&
            typeof e === 'string' &&
            /show|hide/.test(e) &&
            (r.toggle = !1),
          i || (i = new o(t, r)),
          typeof e === 'string')
        ) {
          if (void 0 === i[e]) {
            throw new TypeError('No method named "' + e + '"')
          }
          i[e]()
        }
      }),
      (o.jQueryInterface = function (t) {
        return this.each(function () {
          o.collapseInterface(this, t)
        })
      }),
      e(o, null, [
        {
          key: 'Default',
          get: function () {
            return tt
          }
        },
        {
          key: 'DATA_KEY',
          get: function () {
            return 'bs.collapse'
          }
        }
      ]),
      o
    )
  })(R)
  H.on(
    document,
    'click.bs.collapse.data-api',
    '[data-bs-toggle="collapse"]',
    function (t) {
      t.target.tagName === 'A' && t.preventDefault()
      const e = Y.getDataAttributes(this)
      const n = l(this)
      q.find(n).forEach(function (t) {
        let n
        const i = T(t, 'bs.collapse')
        i
          ? (i._parent === null &&
              typeof e.parent === 'string' &&
              ((i._config.parent = e.parent), (i._parent = i._getParent())),
            (n = 'toggle'))
          : (n = e),
        nt.collapseInterface(t, n)
      })
    }
  ),
  b(function () {
    const t = _()
    if (t) {
      const e = t.fn[J];
      (t.fn[J] = nt.jQueryInterface),
      (t.fn[J].Constructor = nt),
      (t.fn[J].noConflict = function () {
        return (t.fn[J] = e), nt.jQueryInterface
      })
    }
  })
  const it = 'top'
  const ot = 'bottom'
  const rt = 'right'
  const st = 'left'
  const at = [it, ot, rt, st]
  const lt = at.reduce(function (t, e) {
    return t.concat([e + '-start', e + '-end'])
  }, [])
  const ct = [].concat(at, ['auto']).reduce(function (t, e) {
    return t.concat([e, e + '-start', e + '-end'])
  }, [])
  const ut = [
    'beforeRead',
    'read',
    'afterRead',
    'beforeMain',
    'main',
    'afterMain',
    'beforeWrite',
    'write',
    'afterWrite'
  ]
  function ft (t) {
    return t ? (t.nodeName || '').toLowerCase() : null
  }
  function dt (t) {
    if (t.toString() !== '[object Window]') {
      const e = t.ownerDocument
      return (e && e.defaultView) || window
    }
    return t
  }
  function ht (t) {
    return t instanceof dt(t).Element || t instanceof Element
  }
  function pt (t) {
    return t instanceof dt(t).HTMLElement || t instanceof HTMLElement
  }
  const gt = {
    name: 'applyStyles',
    enabled: !0,
    phase: 'write',
    fn: function (t) {
      const e = t.state
      Object.keys(e.elements).forEach(function (t) {
        const n = e.styles[t] || {}
        const i = e.attributes[t] || {}
        const o = e.elements[t]
        pt(o) &&
          ft(o) &&
          (Object.assign(o.style, n),
          Object.keys(i).forEach(function (t) {
            const e = i[t]
            !1 === e
              ? o.removeAttribute(t)
              : o.setAttribute(t, !0 === e ? '' : e)
          }))
      })
    },
    effect: function (t) {
      const e = t.state
      const n = {
        popper: {
          position: e.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: { position: 'absolute' },
        reference: {}
      }
      return (
        Object.assign(e.elements.popper.style, n.popper),
        e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
        function () {
          Object.keys(e.elements).forEach(function (t) {
            const i = e.elements[t]
            const o = e.attributes[t] || {}
            const r = Object.keys(
              e.styles.hasOwnProperty(t) ? e.styles[t] : n[t]
            ).reduce(function (t, e) {
              return (t[e] = ''), t
            }, {})
            pt(i) &&
              ft(i) &&
              (Object.assign(i.style, r),
              Object.keys(o).forEach(function (t) {
                i.removeAttribute(t)
              }))
          })
        }
      )
    },
    requires: ['computeStyles']
  }
  function mt (t) {
    return t.split('-')[0]
  }
  function vt (t) {
    return {
      x: t.offsetLeft,
      y: t.offsetTop,
      width: t.offsetWidth,
      height: t.offsetHeight
    }
  }
  function _t (t, e) {
    let n
    const i = e.getRootNode && e.getRootNode()
    if (t.contains(e)) return !0
    if (i && ((n = i) instanceof dt(n).ShadowRoot || n instanceof ShadowRoot)) {
      let o = e
      do {
        if (o && t.isSameNode(o)) return !0
        o = o.parentNode || o.host
      } while (o)
    }
    return !1
  }
  function bt (t) {
    return dt(t).getComputedStyle(t)
  }
  function yt (t) {
    return ['table', 'td', 'th'].indexOf(ft(t)) >= 0
  }
  function wt (t) {
    return (
      (ht(t) ? t.ownerDocument : t.document) || window.document
    ).documentElement
  }
  function Et (t) {
    return ft(t) === 'html'
      ? t
      : t.assignedSlot || t.parentNode || t.host || wt(t)
  }
  function Tt (t) {
    if (!pt(t) || bt(t).position === 'fixed') return null
    const e = t.offsetParent
    if (e) {
      const n = wt(e)
      if (
        ft(e) === 'body' &&
        bt(e).position === 'static' &&
        bt(n).position !== 'static'
      ) {
        return n
      }
    }
    return e
  }
  function kt (t) {
    for (
      var e = dt(t), n = Tt(t);
      n && yt(n) && bt(n).position === 'static';

    ) {
      n = Tt(n)
    }
    return n && ft(n) === 'body' && bt(n).position === 'static'
      ? e
      : n ||
          (function (t) {
            for (
              let e = Et(t);
              pt(e) && ['html', 'body'].indexOf(ft(e)) < 0;

            ) {
              const n = bt(e)
              if (
                n.transform !== 'none' ||
                n.perspective !== 'none' ||
                (n.willChange && n.willChange !== 'auto')
              ) {
                return e
              }
              e = e.parentNode
            }
            return null
          })(t) ||
          e
  }
  function Ot (t) {
    return ['top', 'bottom'].indexOf(t) >= 0 ? 'x' : 'y'
  }
  function Lt (t, e, n) {
    return Math.max(t, Math.min(e, n))
  }
  function At (t) {
    return Object.assign(
      Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }),
      t
    )
  }
  function Ct (t, e) {
    return e.reduce(function (e, n) {
      return (e[n] = t), e
    }, {})
  }
  const Dt = {
    name: 'arrow',
    enabled: !0,
    phase: 'main',
    fn: function (t) {
      let e
      const n = t.state
      const i = t.name
      const o = n.elements.arrow
      const r = n.modifiersData.popperOffsets
      const s = mt(n.placement)
      const a = Ot(s)
      const l = [st, rt].indexOf(s) >= 0 ? 'height' : 'width'
      if (o && r) {
        const c = n.modifiersData[i + '#persistent'].padding
        const u = vt(o)
        const f = a === 'y' ? it : st
        const d = a === 'y' ? ot : rt
        const h =
          n.rects.reference[l] +
          n.rects.reference[a] -
          r[a] -
          n.rects.popper[l]
        const p = r[a] - n.rects.reference[a]
        const g = kt(o)
        const m = g
          ? a === 'y'
            ? g.clientHeight || 0
            : g.clientWidth || 0
          : 0
        const v = h / 2 - p / 2
        const _ = c[f]
        const b = m - u[l] - c[d]
        const y = m / 2 - u[l] / 2 + v
        const w = Lt(_, y, b)
        const E = a
        n.modifiersData[i] = (((e = {})[E] = w), (e.centerOffset = w - y), e)
      }
    },
    effect: function (t) {
      const e = t.state
      const n = t.options
      const i = t.name
      const o = n.element
      let r = void 0 === o ? '[data-popper-arrow]' : o
      const s = n.padding
      const a = void 0 === s ? 0 : s
      r != null &&
        (typeof r !== 'string' || (r = e.elements.popper.querySelector(r))) &&
        _t(e.elements.popper, r) &&
        ((e.elements.arrow = r),
        (e.modifiersData[i + '#persistent'] = {
          padding: At(typeof a !== 'number' ? a : Ct(a, at))
        }))
    },
    requires: ['popperOffsets'],
    requiresIfExists: ['preventOverflow']
  }
  const xt = { top: 'auto', right: 'auto', bottom: 'auto', left: 'auto' }
  function St (t) {
    let e
    const n = t.popper
    const i = t.popperRect
    const o = t.placement
    const r = t.offsets
    const s = t.position
    const a = t.gpuAcceleration
    const l = t.adaptive
    const c = (function (t) {
      const e = t.x
      const n = t.y
      const i = window.devicePixelRatio || 1
      return { x: Math.round(e * i) / i || 0, y: Math.round(n * i) / i || 0 }
    })(r)
    let u = c.x
    let f = c.y
    const d = r.hasOwnProperty('x')
    const h = r.hasOwnProperty('y')
    let p = st
    let g = it
    const m = window
    if (l) {
      let v = kt(n)
      v === dt(n) && (v = wt(n)),
      o === it &&
          ((g = ot), (f -= v.clientHeight - i.height), (f *= a ? 1 : -1)),
      o === st &&
          ((p = rt), (u -= v.clientWidth - i.width), (u *= a ? 1 : -1))
    }
    let _
    const b = Object.assign({ position: s }, l && xt)
    return a
      ? Object.assign(
        Object.assign({}, b),
        {},
        (((_ = {})[g] = h ? '0' : ''),
        (_[p] = d ? '0' : ''),
        (_.transform =
            (m.devicePixelRatio || 1) < 2
              ? 'translate(' + u + 'px, ' + f + 'px)'
              : 'translate3d(' + u + 'px, ' + f + 'px, 0)'),
        _)
      )
      : Object.assign(
        Object.assign({}, b),
        {},
        (((e = {})[g] = h ? f + 'px' : ''),
        (e[p] = d ? u + 'px' : ''),
        (e.transform = ''),
        e)
      )
  }
  const jt = {
    name: 'computeStyles',
    enabled: !0,
    phase: 'beforeWrite',
    fn: function (t) {
      const e = t.state
      const n = t.options
      const i = n.gpuAcceleration
      const o = void 0 === i || i
      const r = n.adaptive
      const s = void 0 === r || r
      const a = {
        placement: mt(e.placement),
        popper: e.elements.popper,
        popperRect: e.rects.popper,
        gpuAcceleration: o
      }
      e.modifiersData.popperOffsets != null &&
        (e.styles.popper = Object.assign(
          Object.assign({}, e.styles.popper),
          St(
            Object.assign(
              Object.assign({}, a),
              {},
              {
                offsets: e.modifiersData.popperOffsets,
                position: e.options.strategy,
                adaptive: s
              }
            )
          )
        )),
      e.modifiersData.arrow != null &&
          (e.styles.arrow = Object.assign(
            Object.assign({}, e.styles.arrow),
            St(
              Object.assign(
                Object.assign({}, a),
                {},
                {
                  offsets: e.modifiersData.arrow,
                  position: 'absolute',
                  adaptive: !1
                }
              )
            )
          )),
      (e.attributes.popper = Object.assign(
        Object.assign({}, e.attributes.popper),
        {},
        { 'data-popper-placement': e.placement }
      ))
    },
    data: {}
  }
  const Nt = { passive: !0 }
  const It = {
    name: 'eventListeners',
    enabled: !0,
    phase: 'write',
    fn: function () {},
    effect: function (t) {
      const e = t.state
      const n = t.instance
      const i = t.options
      const o = i.scroll
      const r = void 0 === o || o
      const s = i.resize
      const a = void 0 === s || s
      const l = dt(e.elements.popper)
      const c = [].concat(e.scrollParents.reference, e.scrollParents.popper)
      return (
        r &&
          c.forEach(function (t) {
            t.addEventListener('scroll', n.update, Nt)
          }),
        a && l.addEventListener('resize', n.update, Nt),
        function () {
          r &&
            c.forEach(function (t) {
              t.removeEventListener('scroll', n.update, Nt)
            }),
          a && l.removeEventListener('resize', n.update, Nt)
        }
      )
    },
    data: {}
  }
  const Pt = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }
  function Mt (t) {
    return t.replace(/left|right|bottom|top/g, function (t) {
      return Pt[t]
    })
  }
  const Bt = { start: 'end', end: 'start' }
  function Ht (t) {
    return t.replace(/start|end/g, function (t) {
      return Bt[t]
    })
  }
  function Rt (t) {
    const e = t.getBoundingClientRect()
    return {
      width: e.width,
      height: e.height,
      top: e.top,
      right: e.right,
      bottom: e.bottom,
      left: e.left,
      x: e.left,
      y: e.top
    }
  }
  function Wt (t) {
    const e = dt(t)
    return { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset }
  }
  function Kt (t) {
    return Rt(wt(t)).left + Wt(t).scrollLeft
  }
  function Qt (t) {
    const e = bt(t)
    const n = e.overflow
    const i = e.overflowX
    const o = e.overflowY
    return /auto|scroll|overlay|hidden/.test(n + o + i)
  }
  function Ut (t, e) {
    void 0 === e && (e = [])
    const n = (function t (e) {
      return ['html', 'body', '#document'].indexOf(ft(e)) >= 0
        ? e.ownerDocument.body
        : pt(e) && Qt(e)
          ? e
          : t(Et(e))
    })(t)
    const i = ft(n) === 'body'
    const o = dt(n)
    const r = i ? [o].concat(o.visualViewport || [], Qt(n) ? n : []) : n
    const s = e.concat(r)
    return i ? s : s.concat(Ut(Et(r)))
  }
  function Ft (t) {
    return Object.assign(
      Object.assign({}, t),
      {},
      { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height }
    )
  }
  function Yt (t, e) {
    return e === 'viewport'
      ? Ft(
        (function (t) {
          const e = dt(t)
          const n = wt(t)
          const i = e.visualViewport
          let o = n.clientWidth
          let r = n.clientHeight
          let s = 0
          let a = 0
          return (
            i &&
                ((o = i.width),
                (r = i.height),
                /^((?!chrome|android).)*safari/i.test(navigator.userAgent) ||
                  ((s = i.offsetLeft), (a = i.offsetTop))),
            { width: o, height: r, x: s + Kt(t), y: a }
          )
        })(t)
      )
      : pt(e)
        ? (function (t) {
            const e = Rt(t)
            return (
              (e.top = e.top + t.clientTop),
              (e.left = e.left + t.clientLeft),
              (e.bottom = e.top + t.clientHeight),
              (e.right = e.left + t.clientWidth),
              (e.width = t.clientWidth),
              (e.height = t.clientHeight),
              (e.x = e.left),
              (e.y = e.top),
              e
            )
          })(e)
        : Ft(
          (function (t) {
            const e = wt(t)
            const n = Wt(t)
            const i = t.ownerDocument.body
            const o = Math.max(
              e.scrollWidth,
              e.clientWidth,
              i ? i.scrollWidth : 0,
              i ? i.clientWidth : 0
            )
            const r = Math.max(
              e.scrollHeight,
              e.clientHeight,
              i ? i.scrollHeight : 0,
              i ? i.clientHeight : 0
            )
            let s = -n.scrollLeft + Kt(t)
            const a = -n.scrollTop
            return (
              bt(i || e).direction === 'rtl' &&
                (s += Math.max(e.clientWidth, i ? i.clientWidth : 0) - o),
              { width: o, height: r, x: s, y: a }
            )
          })(wt(t))
        )
  }
  function qt (t, e, n) {
    const i =
      e === 'clippingParents'
        ? (function (t) {
            const e = Ut(Et(t))
            const n =
              ['absolute', 'fixed'].indexOf(bt(t).position) >= 0 && pt(t)
                ? kt(t)
                : t
            return ht(n)
              ? e.filter(function (t) {
                return ht(t) && _t(t, n) && ft(t) !== 'body'
              })
              : []
          })(t)
        : [].concat(e)
    const o = [].concat(i, [n])
    const r = o[0]
    const s = o.reduce(function (e, n) {
      const i = Yt(t, n)
      return (
        (e.top = Math.max(i.top, e.top)),
        (e.right = Math.min(i.right, e.right)),
        (e.bottom = Math.min(i.bottom, e.bottom)),
        (e.left = Math.max(i.left, e.left)),
        e
      )
    }, Yt(t, r))
    return (
      (s.width = s.right - s.left),
      (s.height = s.bottom - s.top),
      (s.x = s.left),
      (s.y = s.top),
      s
    )
  }
  function zt (t) {
    return t.split('-')[1]
  }
  function Vt (t) {
    let e
    const n = t.reference
    const i = t.element
    const o = t.placement
    const r = o ? mt(o) : null
    const s = o ? zt(o) : null
    const a = n.x + n.width / 2 - i.width / 2
    const l = n.y + n.height / 2 - i.height / 2
    switch (r) {
      case it:
        e = { x: a, y: n.y - i.height }
        break
      case ot:
        e = { x: a, y: n.y + n.height }
        break
      case rt:
        e = { x: n.x + n.width, y: l }
        break
      case st:
        e = { x: n.x - i.width, y: l }
        break
      default:
        e = { x: n.x, y: n.y }
    }
    const c = r ? Ot(r) : null
    if (c != null) {
      const u = c === 'y' ? 'height' : 'width'
      switch (s) {
        case 'start':
          e[c] = Math.floor(e[c]) - Math.floor(n[u] / 2 - i[u] / 2)
          break
        case 'end':
          e[c] = Math.floor(e[c]) + Math.ceil(n[u] / 2 - i[u] / 2)
      }
    }
    return e
  }
  function Xt (t, e) {
    void 0 === e && (e = {})
    const n = e
    const i = n.placement
    const o = void 0 === i ? t.placement : i
    const r = n.boundary
    const s = void 0 === r ? 'clippingParents' : r
    const a = n.rootBoundary
    const l = void 0 === a ? 'viewport' : a
    const c = n.elementContext
    const u = void 0 === c ? 'popper' : c
    const f = n.altBoundary
    const d = void 0 !== f && f
    const h = n.padding
    const p = void 0 === h ? 0 : h
    const g = At(typeof p !== 'number' ? p : Ct(p, at))
    const m = u === 'popper' ? 'reference' : 'popper'
    const v = t.elements.reference
    const _ = t.rects.popper
    const b = t.elements[d ? m : u]
    const y = qt(ht(b) ? b : b.contextElement || wt(t.elements.popper), s, l)
    const w = Rt(v)
    const E = Vt({
      reference: w,
      element: _,
      strategy: 'absolute',
      placement: o
    })
    const T = Ft(Object.assign(Object.assign({}, _), E))
    const k = u === 'popper' ? T : w
    const O = {
      top: y.top - k.top + g.top,
      bottom: k.bottom - y.bottom + g.bottom,
      left: y.left - k.left + g.left,
      right: k.right - y.right + g.right
    }
    const L = t.modifiersData.offset
    if (u === 'popper' && L) {
      const A = L[o]
      Object.keys(O).forEach(function (t) {
        const e = [rt, ot].indexOf(t) >= 0 ? 1 : -1
        const n = [it, ot].indexOf(t) >= 0 ? 'y' : 'x'
        O[t] += A[n] * e
      })
    }
    return O
  }
  function $t (t, e) {
    void 0 === e && (e = {})
    const n = e
    const i = n.placement
    const o = n.boundary
    const r = n.rootBoundary
    const s = n.padding
    const a = n.flipVariations
    const l = n.allowedAutoPlacements
    const c = void 0 === l ? ct : l
    const u = zt(i)
    const f = u
      ? a
        ? lt
        : lt.filter(function (t) {
          return zt(t) === u
        })
      : at
    let d = f.filter(function (t) {
      return c.indexOf(t) >= 0
    })
    d.length === 0 && (d = f)
    const h = d.reduce(function (e, n) {
      return (
        (e[n] = Xt(t, {
          placement: n,
          boundary: o,
          rootBoundary: r,
          padding: s
        })[mt(n)]),
        e
      )
    }, {})
    return Object.keys(h).sort(function (t, e) {
      return h[t] - h[e]
    })
  }
  const Gt = {
    name: 'flip',
    enabled: !0,
    phase: 'main',
    fn: function (t) {
      const e = t.state
      const n = t.options
      const i = t.name
      if (!e.modifiersData[i]._skip) {
        for (
          var o = n.mainAxis,
            r = void 0 === o || o,
            s = n.altAxis,
            a = void 0 === s || s,
            l = n.fallbackPlacements,
            c = n.padding,
            u = n.boundary,
            f = n.rootBoundary,
            d = n.altBoundary,
            h = n.flipVariations,
            p = void 0 === h || h,
            g = n.allowedAutoPlacements,
            m = e.options.placement,
            v = mt(m),
            _ =
              l ||
              (v === m || !p
                ? [Mt(m)]
                : (function (t) {
                    if (mt(t) === 'auto') return []
                    const e = Mt(t)
                    return [Ht(t), e, Ht(e)]
                  })(m)),
            b = [m].concat(_).reduce(function (t, n) {
              return t.concat(
                mt(n) === 'auto'
                  ? $t(e, {
                    placement: n,
                    boundary: u,
                    rootBoundary: f,
                    padding: c,
                    flipVariations: p,
                    allowedAutoPlacements: g
                  })
                  : n
              )
            }, []),
            y = e.rects.reference,
            w = e.rects.popper,
            E = new Map(),
            T = !0,
            k = b[0],
            O = 0;
          O < b.length;
          O++
        ) {
          const L = b[O]
          const A = mt(L)
          const C = zt(L) === 'start'
          const D = [it, ot].indexOf(A) >= 0
          const x = D ? 'width' : 'height'
          const S = Xt(e, {
            placement: L,
            boundary: u,
            rootBoundary: f,
            altBoundary: d,
            padding: c
          })
          let j = D ? (C ? rt : st) : C ? ot : it
          y[x] > w[x] && (j = Mt(j))
          const N = Mt(j)
          const I = []
          if (
            (r && I.push(S[A] <= 0),
            a && I.push(S[j] <= 0, S[N] <= 0),
            I.every(function (t) {
              return t
            }))
          ) {
            (k = L), (T = !1)
            break
          }
          E.set(L, I)
        }
        if (T) {
          for (
            let P = function (t) {
                const e = b.find(function (e) {
                  const n = E.get(e)
                  if (n) {
                    return n.slice(0, t).every(function (t) {
                      return t
                    })
                  }
                })
                if (e) return (k = e), 'break'
              },
              M = p ? 3 : 1;
            M > 0;
            M--
          ) {
            if (P(M) === 'break') break
          }
        }
        e.placement !== k &&
          ((e.modifiersData[i]._skip = !0), (e.placement = k), (e.reset = !0))
      }
    },
    requiresIfExists: ['offset'],
    data: { _skip: !1 }
  }
  function Zt (t, e, n) {
    return (
      void 0 === n && (n = { x: 0, y: 0 }),
      {
        top: t.top - e.height - n.y,
        right: t.right - e.width + n.x,
        bottom: t.bottom - e.height + n.y,
        left: t.left - e.width - n.x
      }
    )
  }
  function Jt (t) {
    return [it, rt, ot, st].some(function (e) {
      return t[e] >= 0
    })
  }
  const te = {
    name: 'hide',
    enabled: !0,
    phase: 'main',
    requiresIfExists: ['preventOverflow'],
    fn: function (t) {
      const e = t.state
      const n = t.name
      const i = e.rects.reference
      const o = e.rects.popper
      const r = e.modifiersData.preventOverflow
      const s = Xt(e, { elementContext: 'reference' })
      const a = Xt(e, { altBoundary: !0 })
      const l = Zt(s, i)
      const c = Zt(a, o, r)
      const u = Jt(l)
      const f = Jt(c);
      (e.modifiersData[n] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: c,
        isReferenceHidden: u,
        hasPopperEscaped: f
      }),
      (e.attributes.popper = Object.assign(
        Object.assign({}, e.attributes.popper),
        {},
        { 'data-popper-reference-hidden': u, 'data-popper-escaped': f }
      ))
    }
  }
  const ee = {
    name: 'offset',
    enabled: !0,
    phase: 'main',
    requires: ['popperOffsets'],
    fn: function (t) {
      const e = t.state
      const n = t.options
      const i = t.name
      const o = n.offset
      const r = void 0 === o ? [0, 0] : o
      const s = ct.reduce(function (t, n) {
        return (
          (t[n] = (function (t, e, n) {
            const i = mt(t)
            const o = [st, it].indexOf(i) >= 0 ? -1 : 1
            const r =
              typeof n === 'function'
                ? n(Object.assign(Object.assign({}, e), {}, { placement: t }))
                : n
            let s = r[0]
            let a = r[1]
            return (
              (s = s || 0),
              (a = (a || 0) * o),
              [st, rt].indexOf(i) >= 0 ? { x: a, y: s } : { x: s, y: a }
            )
          })(n, e.rects, r)),
          t
        )
      }, {})
      const a = s[e.placement]
      const l = a.x
      const c = a.y
      e.modifiersData.popperOffsets != null &&
        ((e.modifiersData.popperOffsets.x += l),
        (e.modifiersData.popperOffsets.y += c)),
      (e.modifiersData[i] = s)
    }
  }
  const ne = {
    name: 'popperOffsets',
    enabled: !0,
    phase: 'read',
    fn: function (t) {
      const e = t.state
      const n = t.name
      e.modifiersData[n] = Vt({
        reference: e.rects.reference,
        element: e.rects.popper,
        strategy: 'absolute',
        placement: e.placement
      })
    },
    data: {}
  }
  const ie = {
    name: 'preventOverflow',
    enabled: !0,
    phase: 'main',
    fn: function (t) {
      const e = t.state
      const n = t.options
      const i = t.name
      const o = n.mainAxis
      const r = void 0 === o || o
      const s = n.altAxis
      const a = void 0 !== s && s
      const l = n.boundary
      const c = n.rootBoundary
      const u = n.altBoundary
      const f = n.padding
      const d = n.tether
      const h = void 0 === d || d
      const p = n.tetherOffset
      const g = void 0 === p ? 0 : p
      const m = Xt(e, {
        boundary: l,
        rootBoundary: c,
        padding: f,
        altBoundary: u
      })
      const v = mt(e.placement)
      const _ = zt(e.placement)
      const b = !_
      const y = Ot(v)
      const w = y === 'x' ? 'y' : 'x'
      const E = e.modifiersData.popperOffsets
      const T = e.rects.reference
      const k = e.rects.popper
      const O =
        typeof g === 'function'
          ? g(
            Object.assign(
              Object.assign({}, e.rects),
              {},
              { placement: e.placement }
            )
          )
          : g
      const L = { x: 0, y: 0 }
      if (E) {
        if (r) {
          const A = y === 'y' ? it : st
          const C = y === 'y' ? ot : rt
          const D = y === 'y' ? 'height' : 'width'
          const x = E[y]
          const S = E[y] + m[A]
          const j = E[y] - m[C]
          const N = h ? -k[D] / 2 : 0
          const I = _ === 'start' ? T[D] : k[D]
          const P = _ === 'start' ? -k[D] : -T[D]
          const M = e.elements.arrow
          const B = h && M ? vt(M) : { width: 0, height: 0 }
          const H = e.modifiersData['arrow#persistent']
            ? e.modifiersData['arrow#persistent'].padding
            : { top: 0, right: 0, bottom: 0, left: 0 }
          const R = H[A]
          const W = H[C]
          const K = Lt(0, T[D], B[D])
          const Q = b ? T[D] / 2 - N - K - R - O : I - K - R - O
          const U = b ? -T[D] / 2 + N + K + W + O : P + K + W + O
          const F = e.elements.arrow && kt(e.elements.arrow)
          const Y = F ? (y === 'y' ? F.clientTop || 0 : F.clientLeft || 0) : 0
          const q = e.modifiersData.offset
            ? e.modifiersData.offset[e.placement][y]
            : 0
          const z = E[y] + Q - q - Y
          const V = E[y] + U - q
          const X = Lt(h ? Math.min(S, z) : S, x, h ? Math.max(j, V) : j);
          (E[y] = X), (L[y] = X - x)
        }
        if (a) {
          const $ = y === 'x' ? it : st
          const G = y === 'x' ? ot : rt
          const Z = E[w]
          const J = Lt(Z + m[$], Z, Z - m[G]);
          (E[w] = J), (L[w] = J - Z)
        }
        e.modifiersData[i] = L
      }
    },
    requiresIfExists: ['offset']
  }
  function oe (t, e, n) {
    void 0 === n && (n = !1)
    let i
    let o
    const r = wt(e)
    const s = Rt(t)
    const a = pt(e)
    let l = { scrollLeft: 0, scrollTop: 0 }
    let c = { x: 0, y: 0 }
    return (
      (a || (!a && !n)) &&
        ((ft(e) !== 'body' || Qt(r)) &&
          (l =
            (i = e) !== dt(i) && pt(i)
              ? { scrollLeft: (o = i).scrollLeft, scrollTop: o.scrollTop }
              : Wt(i)),
        pt(e)
          ? (((c = Rt(e)).x += e.clientLeft), (c.y += e.clientTop))
          : r && (c.x = Kt(r))),
      {
        x: s.left + l.scrollLeft - c.x,
        y: s.top + l.scrollTop - c.y,
        width: s.width,
        height: s.height
      }
    )
  }
  function re (t) {
    const e = new Map()
    const n = new Set()
    const i = []
    return (
      t.forEach(function (t) {
        e.set(t.name, t)
      }),
      t.forEach(function (t) {
        n.has(t.name) ||
          (function t (o) {
            n.add(o.name),
            []
              .concat(o.requires || [], o.requiresIfExists || [])
              .forEach(function (i) {
                if (!n.has(i)) {
                  const o = e.get(i)
                  o && t(o)
                }
              }),
            i.push(o)
          })(t)
      }),
      i
    )
  }
  const se = { placement: 'bottom', modifiers: [], strategy: 'absolute' }
  function ae () {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) {
      e[n] = arguments[n]
    }
    return !e.some(function (t) {
      return !(t && typeof t.getBoundingClientRect === 'function')
    })
  }
  function le (t) {
    void 0 === t && (t = {})
    const e = t
    const n = e.defaultModifiers
    const i = void 0 === n ? [] : n
    const o = e.defaultOptions
    const r = void 0 === o ? se : o
    return function (t, e, n) {
      void 0 === n && (n = r)
      let o
      let s
      let a = {
        placement: 'bottom',
        orderedModifiers: [],
        options: Object.assign(Object.assign({}, se), r),
        modifiersData: {},
        elements: { reference: t, popper: e },
        attributes: {},
        styles: {}
      }
      let l = []
      let c = !1
      var u = {
        state: a,
        setOptions: function (n) {
          f(),
          (a.options = Object.assign(
            Object.assign(Object.assign({}, r), a.options),
            n
          )),
          (a.scrollParents = {
            reference: ht(t)
              ? Ut(t)
              : t.contextElement
                ? Ut(t.contextElement)
                : [],
            popper: Ut(e)
          })
          let o
          let s
          const c = (function (t) {
            const e = re(t)
            return ut.reduce(function (t, n) {
              return t.concat(
                e.filter(function (t) {
                  return t.phase === n
                })
              )
            }, [])
          })(
            ((o = [].concat(i, a.options.modifiers)),
            (s = o.reduce(function (t, e) {
              const n = t[e.name]
              return (
                (t[e.name] = n
                  ? Object.assign(
                    Object.assign(Object.assign({}, n), e),
                    {},
                    {
                      options: Object.assign(
                        Object.assign({}, n.options),
                        e.options
                      ),
                      data: Object.assign(Object.assign({}, n.data), e.data)
                    }
                  )
                  : e),
                t
              )
            }, {})),
            Object.keys(s).map(function (t) {
              return s[t]
            }))
          )
          return (
            (a.orderedModifiers = c.filter(function (t) {
              return t.enabled
            })),
            a.orderedModifiers.forEach(function (t) {
              const e = t.name
              const n = t.options
              const i = void 0 === n ? {} : n
              const o = t.effect
              if (typeof o === 'function') {
                const r = o({ state: a, name: e, instance: u, options: i })
                const s = function () {}
                l.push(r || s)
              }
            }),
            u.update()
          )
        },
        forceUpdate: function () {
          if (!c) {
            const t = a.elements
            const e = t.reference
            const n = t.popper
            if (ae(e, n)) {
              (a.rects = {
                reference: oe(e, kt(n), a.options.strategy === 'fixed'),
                popper: vt(n)
              }),
              (a.reset = !1),
              (a.placement = a.options.placement),
              a.orderedModifiers.forEach(function (t) {
                return (a.modifiersData[t.name] = Object.assign({}, t.data))
              })
              for (let i = 0; i < a.orderedModifiers.length; i++) {
                if (!0 !== a.reset) {
                  const o = a.orderedModifiers[i]
                  const r = o.fn
                  const s = o.options
                  const l = void 0 === s ? {} : s
                  const f = o.name
                  typeof r === 'function' &&
                    (a =
                      r({ state: a, options: l, name: f, instance: u }) || a)
                } else (a.reset = !1), (i = -1)
              }
            }
          }
        },
        update:
          ((o = function () {
            return new Promise(function (t) {
              u.forceUpdate(), t(a)
            })
          }),
          function () {
            return (
              s ||
                (s = new Promise(function (t) {
                  Promise.resolve().then(function () {
                    (s = void 0), t(o())
                  })
                })),
              s
            )
          }),
        destroy: function () {
          f(), (c = !0)
        }
      }
      if (!ae(t, e)) return u
      function f () {
        l.forEach(function (t) {
          return t()
        }),
        (l = [])
      }
      return (
        u.setOptions(n).then(function (t) {
          !c && n.onFirstUpdate && n.onFirstUpdate(t)
        }),
        u
      )
    }
  }
  const ce = le()
  const ue = le({ defaultModifiers: [It, ne, jt, gt] })
  const fe = le({ defaultModifiers: [It, ne, jt, gt, ee, Gt, ie, Dt, te] })
  const de = Object.freeze({
    __proto__: null,
    popperGenerator: le,
    detectOverflow: Xt,
    createPopperBase: ce,
    createPopper: fe,
    createPopperLite: ue,
    top: it,
    bottom: ot,
    right: rt,
    left: st,
    auto: 'auto',
    basePlacements: at,
    start: 'start',
    end: 'end',
    clippingParents: 'clippingParents',
    viewport: 'viewport',
    popper: 'popper',
    reference: 'reference',
    variationPlacements: lt,
    placements: ct,
    beforeRead: 'beforeRead',
    read: 'read',
    afterRead: 'afterRead',
    beforeMain: 'beforeMain',
    main: 'main',
    afterMain: 'afterMain',
    beforeWrite: 'beforeWrite',
    write: 'write',
    afterWrite: 'afterWrite',
    modifierPhases: ut,
    applyStyles: gt,
    arrow: Dt,
    computeStyles: jt,
    eventListeners: It,
    flip: Gt,
    hide: te,
    offset: ee,
    popperOffsets: ne,
    preventOverflow: ie
  })
  const he = 'dropdown'
  const pe = new RegExp('ArrowUp|ArrowDown|Escape')
  const ge = y ? 'top-end' : 'top-start'
  const me = y ? 'top-start' : 'top-end'
  const ve = y ? 'bottom-end' : 'bottom-start'
  const _e = y ? 'bottom-start' : 'bottom-end'
  const be = y ? 'left-start' : 'right-start'
  const ye = y ? 'right-start' : 'left-start'
  const we = {
    offset: 0,
    flip: !0,
    boundary: 'clippingParents',
    reference: 'toggle',
    display: 'dynamic',
    popperConfig: null
  }
  const Ee = {
    offset: '(number|string|function)',
    flip: 'boolean',
    boundary: '(string|element)',
    reference: '(string|element)',
    display: 'string',
    popperConfig: '(null|object)'
  }
  const Te = (function (t) {
    function o (e, n) {
      let i
      return (
        ((i = t.call(this, e) || this)._popper = null),
        (i._config = i._getConfig(n)),
        (i._menu = i._getMenuElement()),
        (i._inNavbar = i._detectNavbar()),
        i._addEventListeners(),
        i
      )
    }
    i(o, t)
    const r = o.prototype
    return (
      (r.toggle = function () {
        if (
          !this._element.disabled &&
          !this._element.classList.contains('disabled')
        ) {
          const t = this._element.classList.contains('show')
          o.clearMenus(), t || this.show()
        }
      }),
      (r.show = function () {
        if (
          !(
            this._element.disabled ||
            this._element.classList.contains('disabled') ||
            this._menu.classList.contains('show')
          )
        ) {
          const t = o.getParentFromElement(this._element)
          const e = { relatedTarget: this._element }
          if (
            !H.trigger(this._element, 'show.bs.dropdown', e).defaultPrevented
          ) {
            if (!this._inNavbar) {
              if (void 0 === de) {
                throw new TypeError(
                  "Bootstrap's dropdowns require Popper (https://popper.js.org)"
                )
              }
              let n = this._element
              this._config.reference === 'parent'
                ? (n = t)
                : d(this._config.reference) &&
                  ((n = this._config.reference),
                  void 0 !== this._config.reference.jquery &&
                    (n = this._config.reference[0])),
              (this._popper = fe(n, this._menu, this._getPopperConfig()))
            }
            let i
            if (
              'ontouchstart' in document.documentElement &&
              !t.closest('.navbar-nav')
            ) {
              (i = []).concat
                .apply(i, document.body.children)
                .forEach(function (t) {
                  return H.on(t, 'mouseover', null, function () {})
                })
            }
            this._element.focus(),
            this._element.setAttribute('aria-expanded', !0),
            this._menu.classList.toggle('show'),
            this._element.classList.toggle('show'),
            H.trigger(t, 'shown.bs.dropdown', e)
          }
        }
      }),
      (r.hide = function () {
        if (
          !this._element.disabled &&
          !this._element.classList.contains('disabled') &&
          this._menu.classList.contains('show')
        ) {
          const t = o.getParentFromElement(this._element)
          const e = { relatedTarget: this._element }
          H.trigger(t, 'hide.bs.dropdown', e).defaultPrevented ||
            (this._popper && this._popper.destroy(),
            this._menu.classList.toggle('show'),
            this._element.classList.toggle('show'),
            H.trigger(t, 'hidden.bs.dropdown', e))
        }
      }),
      (r.dispose = function () {
        t.prototype.dispose.call(this),
        H.off(this._element, '.bs.dropdown'),
        (this._menu = null),
        this._popper && (this._popper.destroy(), (this._popper = null))
      }),
      (r.update = function () {
        (this._inNavbar = this._detectNavbar()),
        this._popper && this._popper.update()
      }),
      (r._addEventListeners = function () {
        const t = this
        H.on(this._element, 'click.bs.dropdown', function (e) {
          e.preventDefault(), e.stopPropagation(), t.toggle()
        })
      }),
      (r._getConfig = function (t) {
        return (
          (t = n(
            {},
            this.constructor.Default,
            Y.getDataAttributes(this._element),
            t
          )),
          p(he, t, this.constructor.DefaultType),
          t
        )
      }),
      (r._getMenuElement = function () {
        return q.next(this._element, '.dropdown-menu')[0]
      }),
      (r._getPlacement = function () {
        const t = this._element.parentNode
        if (t.classList.contains('dropend')) return be
        if (t.classList.contains('dropstart')) return ye
        const e =
          getComputedStyle(this._menu)
            .getPropertyValue('--bs-position')
            .trim() === 'end'
        return t.classList.contains('dropup') ? (e ? me : ge) : e ? _e : ve
      }),
      (r._detectNavbar = function () {
        return this._element.closest('.navbar') !== null
      }),
      (r._getPopperConfig = function () {
        const t = {
          placement: this._getPlacement(),
          modifiers: [
            {
              name: 'preventOverflow',
              options: {
                altBoundary: this._config.flip,
                rootBoundary: this._config.boundary
              }
            }
          ]
        }
        return (
          this._config.display === 'static' &&
            (t.modifiers = [{ name: 'applyStyles', enabled: !1 }]),
          n({}, t, this._config.popperConfig)
        )
      }),
      (o.dropdownInterface = function (t, e) {
        let n = T(t, 'bs.dropdown')
        if (
          (n || (n = new o(t, typeof e === 'object' ? e : null)),
          typeof e === 'string')
        ) {
          if (void 0 === n[e]) {
            throw new TypeError('No method named "' + e + '"')
          }
          n[e]()
        }
      }),
      (o.jQueryInterface = function (t) {
        return this.each(function () {
          o.dropdownInterface(this, t)
        })
      }),
      (o.clearMenus = function (t) {
        if (!t || (t.button !== 2 && (t.type !== 'keyup' || t.key === 'Tab'))) {
          for (
            let e = q.find('[data-bs-toggle="dropdown"]'), n = 0, i = e.length;
            n < i;
            n++
          ) {
            const r = o.getParentFromElement(e[n])
            const s = T(e[n], 'bs.dropdown')
            const a = { relatedTarget: e[n] }
            if ((t && t.type === 'click' && (a.clickEvent = t), s)) {
              const l = s._menu
              if (e[n].classList.contains('show')) {
                if (
                  !(
                    t &&
                    ((t.type === 'click' &&
                      /input|textarea/i.test(t.target.tagName)) ||
                      (t.type === 'keyup' && t.key === 'Tab')) &&
                    l.contains(t.target)
                  )
                ) {
                  if (!H.trigger(r, 'hide.bs.dropdown', a).defaultPrevented) {
                    var c
                    if ('ontouchstart' in document.documentElement) {
                      (c = []).concat
                        .apply(c, document.body.children)
                        .forEach(function (t) {
                          return H.off(t, 'mouseover', null, function () {})
                        })
                    }
                    e[n].setAttribute('aria-expanded', 'false'),
                    s._popper && s._popper.destroy(),
                    l.classList.remove('show'),
                    e[n].classList.remove('show'),
                    H.trigger(r, 'hidden.bs.dropdown', a)
                  }
                }
              }
            }
          }
        }
      }),
      (o.getParentFromElement = function (t) {
        return c(t) || t.parentNode
      }),
      (o.dataApiKeydownHandler = function (t) {
        if (
          !(/input|textarea/i.test(t.target.tagName)
            ? t.key === 'Space' ||
              (t.key !== 'Escape' &&
                ((t.key !== 'ArrowDown' && t.key !== 'ArrowUp') ||
                  t.target.closest('.dropdown-menu')))
            : !pe.test(t.key)) &&
          (t.preventDefault(),
          t.stopPropagation(),
          !this.disabled && !this.classList.contains('disabled'))
        ) {
          const e = o.getParentFromElement(this)
          const n = this.classList.contains('show')
          if (t.key === 'Escape') {
            return (
              (this.matches('[data-bs-toggle="dropdown"]')
                ? this
                : q.prev(this, '[data-bs-toggle="dropdown"]')[0]
              ).focus(),
              void o.clearMenus()
            )
          }
          if (n && t.key !== 'Space') {
            const i = q
              .find(
                '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)',
                e
              )
              .filter(g)
            if (i.length) {
              let r = i.indexOf(t.target)
              t.key === 'ArrowUp' && r > 0 && r--,
              t.key === 'ArrowDown' && r < i.length - 1 && r++,
              i[(r = r === -1 ? 0 : r)].focus()
            }
          } else o.clearMenus()
        }
      }),
      e(o, null, [
        {
          key: 'Default',
          get: function () {
            return we
          }
        },
        {
          key: 'DefaultType',
          get: function () {
            return Ee
          }
        },
        {
          key: 'DATA_KEY',
          get: function () {
            return 'bs.dropdown'
          }
        }
      ]),
      o
    )
  })(R)
  H.on(
    document,
    'keydown.bs.dropdown.data-api',
    '[data-bs-toggle="dropdown"]',
    Te.dataApiKeydownHandler
  ),
  H.on(
    document,
    'keydown.bs.dropdown.data-api',
    '.dropdown-menu',
    Te.dataApiKeydownHandler
  ),
  H.on(document, 'click.bs.dropdown.data-api', Te.clearMenus),
  H.on(document, 'keyup.bs.dropdown.data-api', Te.clearMenus),
  H.on(
    document,
    'click.bs.dropdown.data-api',
    '[data-bs-toggle="dropdown"]',
    function (t) {
      t.preventDefault(),
      t.stopPropagation(),
      Te.dropdownInterface(this, 'toggle')
    }
  ),
  H.on(
    document,
    'click.bs.dropdown.data-api',
    '.dropdown form',
    function (t) {
      return t.stopPropagation()
    }
  ),
  b(function () {
    const t = _()
    if (t) {
      const e = t.fn[he];
      (t.fn[he] = Te.jQueryInterface),
      (t.fn[he].Constructor = Te),
      (t.fn[he].noConflict = function () {
        return (t.fn[he] = e), Te.jQueryInterface
      })
    }
  })
  const ke = { backdrop: !0, keyboard: !0, focus: !0 }
  const Oe = {
    backdrop: '(boolean|string)',
    keyboard: 'boolean',
    focus: 'boolean'
  }
  const Le = (function (t) {
    function o (e, n) {
      let i
      return (
        ((i = t.call(this, e) || this)._config = i._getConfig(n)),
        (i._dialog = q.findOne('.modal-dialog', e)),
        (i._backdrop = null),
        (i._isShown = !1),
        (i._isBodyOverflowing = !1),
        (i._ignoreBackdropClick = !1),
        (i._isTransitioning = !1),
        (i._scrollbarWidth = 0),
        i
      )
    }
    i(o, t)
    const r = o.prototype
    return (
      (r.toggle = function (t) {
        return this._isShown ? this.hide() : this.show(t)
      }),
      (r.show = function (t) {
        const e = this
        if (!this._isShown && !this._isTransitioning) {
          this._element.classList.contains('fade') &&
            (this._isTransitioning = !0)
          const n = H.trigger(this._element, 'show.bs.modal', {
            relatedTarget: t
          })
          this._isShown ||
            n.defaultPrevented ||
            ((this._isShown = !0),
            this._checkScrollbar(),
            this._setScrollbar(),
            this._adjustDialog(),
            this._setEscapeEvent(),
            this._setResizeEvent(),
            H.on(
              this._element,
              'click.dismiss.bs.modal',
              '[data-bs-dismiss="modal"]',
              function (t) {
                return e.hide(t)
              }
            ),
            H.on(this._dialog, 'mousedown.dismiss.bs.modal', function () {
              H.one(e._element, 'mouseup.dismiss.bs.modal', function (t) {
                t.target === e._element && (e._ignoreBackdropClick = !0)
              })
            }),
            this._showBackdrop(function () {
              return e._showElement(t)
            }))
        }
      }),
      (r.hide = function (t) {
        const e = this
        if (
          (t && t.preventDefault(), this._isShown && !this._isTransitioning) &&
          !H.trigger(this._element, 'hide.bs.modal').defaultPrevented
        ) {
          this._isShown = !1
          const n = this._element.classList.contains('fade')
          if (
            (n && (this._isTransitioning = !0),
            this._setEscapeEvent(),
            this._setResizeEvent(),
            H.off(document, 'focusin.bs.modal'),
            this._element.classList.remove('show'),
            H.off(this._element, 'click.dismiss.bs.modal'),
            H.off(this._dialog, 'mousedown.dismiss.bs.modal'),
            n)
          ) {
            const i = u(this._element)
            H.one(this._element, 'transitionend', function (t) {
              return e._hideModal(t)
            }),
            h(this._element, i)
          } else this._hideModal()
        }
      }),
      (r.dispose = function () {
        [window, this._element, this._dialog].forEach(function (t) {
          return H.off(t, '.bs.modal')
        }),
        t.prototype.dispose.call(this),
        H.off(document, 'focusin.bs.modal'),
        (this._config = null),
        (this._dialog = null),
        (this._backdrop = null),
        (this._isShown = null),
        (this._isBodyOverflowing = null),
        (this._ignoreBackdropClick = null),
        (this._isTransitioning = null),
        (this._scrollbarWidth = null)
      }),
      (r.handleUpdate = function () {
        this._adjustDialog()
      }),
      (r._getConfig = function (t) {
        return (t = n({}, ke, t)), p('modal', t, Oe), t
      }),
      (r._showElement = function (t) {
        const e = this
        const n = this._element.classList.contains('fade')
        const i = q.findOne('.modal-body', this._dialog);
        (this._element.parentNode &&
          this._element.parentNode.nodeType === Node.ELEMENT_NODE) ||
          document.body.appendChild(this._element),
        (this._element.style.display = 'block'),
        this._element.removeAttribute('aria-hidden'),
        this._element.setAttribute('aria-modal', !0),
        this._element.setAttribute('role', 'dialog'),
        (this._element.scrollTop = 0),
        i && (i.scrollTop = 0),
        n && v(this._element),
        this._element.classList.add('show'),
        this._config.focus && this._enforceFocus()
        const o = function () {
          e._config.focus && e._element.focus(),
          (e._isTransitioning = !1),
          H.trigger(e._element, 'shown.bs.modal', { relatedTarget: t })
        }
        if (n) {
          const r = u(this._dialog)
          H.one(this._dialog, 'transitionend', o), h(this._dialog, r)
        } else o()
      }),
      (r._enforceFocus = function () {
        const t = this
        H.off(document, 'focusin.bs.modal'),
        H.on(document, 'focusin.bs.modal', function (e) {
          document === e.target ||
              t._element === e.target ||
              t._element.contains(e.target) ||
              t._element.focus()
        })
      }),
      (r._setEscapeEvent = function () {
        const t = this
        this._isShown
          ? H.on(this._element, 'keydown.dismiss.bs.modal', function (e) {
            t._config.keyboard && e.key === 'Escape'
              ? (e.preventDefault(), t.hide())
              : t._config.keyboard ||
                  e.key !== 'Escape' ||
                  t._triggerBackdropTransition()
          })
          : H.off(this._element, 'keydown.dismiss.bs.modal')
      }),
      (r._setResizeEvent = function () {
        const t = this
        this._isShown
          ? H.on(window, 'resize.bs.modal', function () {
            return t._adjustDialog()
          })
          : H.off(window, 'resize.bs.modal')
      }),
      (r._hideModal = function () {
        const t = this;
        (this._element.style.display = 'none'),
        this._element.setAttribute('aria-hidden', !0),
        this._element.removeAttribute('aria-modal'),
        this._element.removeAttribute('role'),
        (this._isTransitioning = !1),
        this._showBackdrop(function () {
          document.body.classList.remove('modal-open'),
          t._resetAdjustments(),
          t._resetScrollbar(),
          H.trigger(t._element, 'hidden.bs.modal')
        })
      }),
      (r._removeBackdrop = function () {
        this._backdrop.parentNode.removeChild(this._backdrop),
        (this._backdrop = null)
      }),
      (r._showBackdrop = function (t) {
        const e = this
        const n = this._element.classList.contains('fade') ? 'fade' : ''
        if (this._isShown && this._config.backdrop) {
          if (
            ((this._backdrop = document.createElement('div')),
            (this._backdrop.className = 'modal-backdrop'),
            n && this._backdrop.classList.add(n),
            document.body.appendChild(this._backdrop),
            H.on(this._element, 'click.dismiss.bs.modal', function (t) {
              e._ignoreBackdropClick
                ? (e._ignoreBackdropClick = !1)
                : t.target === t.currentTarget &&
                  (e._config.backdrop === 'static'
                    ? e._triggerBackdropTransition()
                    : e.hide())
            }),
            n && v(this._backdrop),
            this._backdrop.classList.add('show'),
            !n)
          ) {
            return void t()
          }
          const i = u(this._backdrop)
          H.one(this._backdrop, 'transitionend', t), h(this._backdrop, i)
        } else if (!this._isShown && this._backdrop) {
          this._backdrop.classList.remove('show')
          const o = function () {
            e._removeBackdrop(), t()
          }
          if (this._element.classList.contains('fade')) {
            const r = u(this._backdrop)
            H.one(this._backdrop, 'transitionend', o), h(this._backdrop, r)
          } else o()
        } else t()
      }),
      (r._triggerBackdropTransition = function () {
        const t = this
        if (
          !H.trigger(this._element, 'hidePrevented.bs.modal').defaultPrevented
        ) {
          const e =
            this._element.scrollHeight > document.documentElement.clientHeight
          e || (this._element.style.overflowY = 'hidden'),
          this._element.classList.add('modal-static')
          const n = u(this._dialog)
          H.off(this._element, 'transitionend'),
          H.one(this._element, 'transitionend', function () {
            t._element.classList.remove('modal-static'),
            e ||
                  (H.one(t._element, 'transitionend', function () {
                    t._element.style.overflowY = ''
                  }),
                  h(t._element, n))
          }),
          h(this._element, n),
          this._element.focus()
        }
      }),
      (r._adjustDialog = function () {
        const t =
          this._element.scrollHeight > document.documentElement.clientHeight;
        ((!this._isBodyOverflowing && t && !y) ||
          (this._isBodyOverflowing && !t && y)) &&
          (this._element.style.paddingLeft = this._scrollbarWidth + 'px'),
        ((this._isBodyOverflowing && !t && !y) ||
            (!this._isBodyOverflowing && t && y)) &&
            (this._element.style.paddingRight = this._scrollbarWidth + 'px')
      }),
      (r._resetAdjustments = function () {
        (this._element.style.paddingLeft = ''),
        (this._element.style.paddingRight = '')
      }),
      (r._checkScrollbar = function () {
        const t = document.body.getBoundingClientRect();
        (this._isBodyOverflowing =
          Math.round(t.left + t.right) < window.innerWidth),
        (this._scrollbarWidth = this._getScrollbarWidth())
      }),
      (r._setScrollbar = function () {
        const t = this
        if (this._isBodyOverflowing) {
          q
            .find('.fixed-top, .fixed-bottom, .is-fixed, .sticky-top')
            .forEach(function (e) {
              const n = e.style.paddingRight
              const i = window.getComputedStyle(e)['padding-right']
              Y.setDataAttribute(e, 'padding-right', n),
              (e.style.paddingRight =
                  Number.parseFloat(i) + t._scrollbarWidth + 'px')
            }),
          q.find('.sticky-top').forEach(function (e) {
            const n = e.style.marginRight
            const i = window.getComputedStyle(e)['margin-right']
            Y.setDataAttribute(e, 'margin-right', n),
            (e.style.marginRight =
                  Number.parseFloat(i) - t._scrollbarWidth + 'px')
          })
          const e = document.body.style.paddingRight
          const n = window.getComputedStyle(document.body)['padding-right']
          Y.setDataAttribute(document.body, 'padding-right', e),
          (document.body.style.paddingRight =
              Number.parseFloat(n) + this._scrollbarWidth + 'px')
        }
        document.body.classList.add('modal-open')
      }),
      (r._resetScrollbar = function () {
        q
          .find('.fixed-top, .fixed-bottom, .is-fixed, .sticky-top')
          .forEach(function (t) {
            const e = Y.getDataAttribute(t, 'padding-right')
            void 0 !== e &&
              (Y.removeDataAttribute(t, 'padding-right'),
              (t.style.paddingRight = e))
          }),
        q.find('.sticky-top').forEach(function (t) {
          const e = Y.getDataAttribute(t, 'margin-right')
          void 0 !== e &&
              (Y.removeDataAttribute(t, 'margin-right'),
              (t.style.marginRight = e))
        })
        const t = Y.getDataAttribute(document.body, 'padding-right')
        void 0 === t
          ? (document.body.style.paddingRight = '')
          : (Y.removeDataAttribute(document.body, 'padding-right'),
            (document.body.style.paddingRight = t))
      }),
      (r._getScrollbarWidth = function () {
        const t = document.createElement('div');
        (t.className = 'modal-scrollbar-measure'), document.body.appendChild(t)
        const e = t.getBoundingClientRect().width - t.clientWidth
        return document.body.removeChild(t), e
      }),
      (o.jQueryInterface = function (t, e) {
        return this.each(function () {
          let i = T(this, 'bs.modal')
          const r = n(
            {},
            ke,
            Y.getDataAttributes(this),
            typeof t === 'object' && t ? t : {}
          )
          if ((i || (i = new o(this, r)), typeof t === 'string')) {
            if (void 0 === i[t]) {
              throw new TypeError('No method named "' + t + '"')
            }
            i[t](e)
          }
        })
      }),
      e(o, null, [
        {
          key: 'Default',
          get: function () {
            return ke
          }
        },
        {
          key: 'DATA_KEY',
          get: function () {
            return 'bs.modal'
          }
        }
      ]),
      o
    )
  })(R)
  H.on(
    document,
    'click.bs.modal.data-api',
    '[data-bs-toggle="modal"]',
    function (t) {
      const e = this
      const i = c(this);
      (this.tagName !== 'A' && this.tagName !== 'AREA') || t.preventDefault(),
      H.one(i, 'show.bs.modal', function (t) {
        t.defaultPrevented ||
            H.one(i, 'hidden.bs.modal', function () {
              g(e) && e.focus()
            })
      })
      let o = T(i, 'bs.modal')
      if (!o) {
        const r = n({}, Y.getDataAttributes(i), Y.getDataAttributes(this))
        o = new Le(i, r)
      }
      o.show(this)
    }
  ),
  b(function () {
    const t = _()
    if (t) {
      const e = t.fn.modal;
      (t.fn.modal = Le.jQueryInterface),
      (t.fn.modal.Constructor = Le),
      (t.fn.modal.noConflict = function () {
        return (t.fn.modal = e), Le.jQueryInterface
      })
    }
  })
  const Ae = new Set([
    'background',
    'cite',
    'href',
    'itemtype',
    'longdesc',
    'poster',
    'src',
    'xlink:href'
  ])
  const Ce = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi
  const De =
    /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i
  const xe = {
    '*': ['class', 'dir', 'id', 'lang', 'role', /^aria-[\w-]*$/i],
    a: ['target', 'href', 'title', 'rel'],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  }
  function Se (t, e, n) {
    let i
    if (!t.length) return t
    if (n && typeof n === 'function') return n(t)
    for (
      var o = new window.DOMParser().parseFromString(t, 'text/html'),
        r = Object.keys(e),
        s = (i = []).concat.apply(i, o.body.querySelectorAll('*')),
        a = function (t, n) {
          let i
          const o = s[t]
          const a = o.nodeName.toLowerCase()
          if (!r.includes(a)) return o.parentNode.removeChild(o), 'continue'
          const l = (i = []).concat.apply(i, o.attributes)
          const c = [].concat(e['*'] || [], e[a] || [])
          l.forEach(function (t) {
            (function (t, e) {
              const n = t.nodeName.toLowerCase()
              if (e.includes(n)) {
                return (
                  !Ae.has(n) ||
                  Boolean(t.nodeValue.match(Ce) || t.nodeValue.match(De))
                )
              }
              for (
                let i = e.filter(function (t) {
                    return t instanceof RegExp
                  }),
                  o = 0,
                  r = i.length;
                o < r;
                o++
              ) {
                if (n.match(i[o])) return !0
              }
              return !1
            })(t, c) || o.removeAttribute(t.nodeName)
          })
        },
        l = 0,
        c = s.length;
      l < c;
      l++
    ) {
      a(l)
    }
    return o.body.innerHTML
  }
  const je = 'tooltip'
  const Ne = new RegExp('(^|\\s)bs-tooltip\\S+', 'g')
  const Ie = new Set(['sanitize', 'allowList', 'sanitizeFn'])
  const Pe = {
    animation: 'boolean',
    template: 'string',
    title: '(string|element|function)',
    trigger: 'string',
    delay: '(number|object)',
    html: 'boolean',
    selector: '(string|boolean)',
    placement: '(string|function)',
    container: '(string|element|boolean)',
    fallbackPlacements: '(null|array)',
    boundary: '(string|element)',
    customClass: '(string|function)',
    sanitize: 'boolean',
    sanitizeFn: '(null|function)',
    allowList: 'object',
    popperConfig: '(null|object)'
  }
  const Me = {
    AUTO: 'auto',
    TOP: 'top',
    RIGHT: y ? 'left' : 'right',
    BOTTOM: 'bottom',
    LEFT: y ? 'right' : 'left'
  }
  const Be = {
    animation: !0,
    template:
      '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: !1,
    selector: !1,
    placement: 'top',
    container: !1,
    fallbackPlacements: null,
    boundary: 'clippingParents',
    customClass: '',
    sanitize: !0,
    sanitizeFn: null,
    allowList: xe,
    popperConfig: null
  }
  const He = {
    HIDE: 'hide.bs.tooltip',
    HIDDEN: 'hidden.bs.tooltip',
    SHOW: 'show.bs.tooltip',
    SHOWN: 'shown.bs.tooltip',
    INSERTED: 'inserted.bs.tooltip',
    CLICK: 'click.bs.tooltip',
    FOCUSIN: 'focusin.bs.tooltip',
    FOCUSOUT: 'focusout.bs.tooltip',
    MOUSEENTER: 'mouseenter.bs.tooltip',
    MOUSELEAVE: 'mouseleave.bs.tooltip'
  }
  const Re = (function (t) {
    function o (e, n) {
      let i
      if (void 0 === de) {
        throw new TypeError(
          "Bootstrap's tooltips require Popper (https://popper.js.org)"
        )
      }
      return (
        ((i = t.call(this, e) || this)._isEnabled = !0),
        (i._timeout = 0),
        (i._hoverState = ''),
        (i._activeTrigger = {}),
        (i._popper = null),
        (i.config = i._getConfig(n)),
        (i.tip = null),
        i._setListeners(),
        i
      )
    }
    i(o, t)
    const r = o.prototype
    return (
      (r.enable = function () {
        this._isEnabled = !0
      }),
      (r.disable = function () {
        this._isEnabled = !1
      }),
      (r.toggleEnabled = function () {
        this._isEnabled = !this._isEnabled
      }),
      (r.toggle = function (t) {
        if (this._isEnabled) {
          if (t) {
            const e = this.constructor.DATA_KEY
            let n = T(t.delegateTarget, e)
            n ||
              ((n = new this.constructor(
                t.delegateTarget,
                this._getDelegateConfig()
              )),
              E(t.delegateTarget, e, n)),
            (n._activeTrigger.click = !n._activeTrigger.click),
            n._isWithActiveTrigger() ? n._enter(null, n) : n._leave(null, n)
          } else {
            if (this.getTipElement().classList.contains('show')) {
              return void this._leave(null, this)
            }
            this._enter(null, this)
          }
        }
      }),
      (r.dispose = function () {
        clearTimeout(this._timeout),
        H.off(this._element, this.constructor.EVENT_KEY),
        H.off(
          this._element.closest('.modal'),
          'hide.bs.modal',
          this._hideModalHandler
        ),
        this.tip && this.tip.parentNode.removeChild(this.tip),
        (this._isEnabled = null),
        (this._timeout = null),
        (this._hoverState = null),
        (this._activeTrigger = null),
        this._popper && this._popper.destroy(),
        (this._popper = null),
        (this.config = null),
        (this.tip = null),
        t.prototype.dispose.call(this)
      }),
      (r.show = function () {
        const t = this
        if (this._element.style.display === 'none') {
          throw new Error('Please use show on visible elements')
        }
        if (this.isWithContent() && this._isEnabled) {
          const e = H.trigger(this._element, this.constructor.Event.SHOW)
          const n = (function t (e) {
            if (!document.documentElement.attachShadow) return null
            if (typeof e.getRootNode === 'function') {
              const n = e.getRootNode()
              return n instanceof ShadowRoot ? n : null
            }
            return e instanceof ShadowRoot
              ? e
              : e.parentNode
                ? t(e.parentNode)
                : null
          })(this._element)
          const i =
            n === null
              ? this._element.ownerDocument.documentElement.contains(
                this._element
              )
              : n.contains(this._element)
          if (e.defaultPrevented || !i) return
          const o = this.getTipElement()
          const r = s(this.constructor.NAME)
          o.setAttribute('id', r),
          this._element.setAttribute('aria-describedby', r),
          this.setContent(),
          this.config.animation && o.classList.add('fade')
          const a =
            typeof this.config.placement === 'function'
              ? this.config.placement.call(this, o, this._element)
              : this.config.placement
          const l = this._getAttachment(a)
          this._addAttachmentClass(l)
          const c = this._getContainer()
          E(o, this.constructor.DATA_KEY, this),
          this._element.ownerDocument.documentElement.contains(this.tip) ||
              c.appendChild(o),
          H.trigger(this._element, this.constructor.Event.INSERTED),
          (this._popper = fe(this._element, o, this._getPopperConfig(l))),
          o.classList.add('show')
          let f
          let d
          const p =
            typeof this.config.customClass === 'function'
              ? this.config.customClass()
              : this.config.customClass
          if (p) (f = o.classList).add.apply(f, p.split(' '))
          if ('ontouchstart' in document.documentElement) {
            (d = []).concat
              .apply(d, document.body.children)
              .forEach(function (t) {
                H.on(t, 'mouseover', function () {})
              })
          }
          const g = function () {
            const e = t._hoverState;
            (t._hoverState = null),
            H.trigger(t._element, t.constructor.Event.SHOWN),
            e === 'out' && t._leave(null, t)
          }
          if (this.tip.classList.contains('fade')) {
            const m = u(this.tip)
            H.one(this.tip, 'transitionend', g), h(this.tip, m)
          } else g()
        }
      }),
      (r.hide = function () {
        const t = this
        if (this._popper) {
          const e = this.getTipElement()
          const n = function () {
            t._hoverState !== 'show' &&
              e.parentNode &&
              e.parentNode.removeChild(e),
            t._cleanTipClass(),
            t._element.removeAttribute('aria-describedby'),
            H.trigger(t._element, t.constructor.Event.HIDDEN),
            t._popper && (t._popper.destroy(), (t._popper = null))
          }
          if (
            !H.trigger(this._element, this.constructor.Event.HIDE)
              .defaultPrevented
          ) {
            let i
            if (
              (e.classList.remove('show'),
              'ontouchstart' in document.documentElement)
            ) {
              (i = []).concat
                .apply(i, document.body.children)
                .forEach(function (t) {
                  return H.off(t, 'mouseover', m)
                })
            }
            if (
              ((this._activeTrigger.click = !1),
              (this._activeTrigger.focus = !1),
              (this._activeTrigger.hover = !1),
              this.tip.classList.contains('fade'))
            ) {
              const o = u(e)
              H.one(e, 'transitionend', n), h(e, o)
            } else n()
            this._hoverState = ''
          }
        }
      }),
      (r.update = function () {
        this._popper !== null && this._popper.update()
      }),
      (r.isWithContent = function () {
        return Boolean(this.getTitle())
      }),
      (r.getTipElement = function () {
        if (this.tip) return this.tip
        const t = document.createElement('div')
        return (
          (t.innerHTML = this.config.template),
          (this.tip = t.children[0]),
          this.tip
        )
      }),
      (r.setContent = function () {
        const t = this.getTipElement()
        this.setElementContent(q.findOne('.tooltip-inner', t), this.getTitle()),
        t.classList.remove('fade', 'show')
      }),
      (r.setElementContent = function (t, e) {
        if (t !== null) {
          return typeof e === 'object' && d(e)
            ? (e.jquery && (e = e[0]),
              void (this.config.html
                ? e.parentNode !== t && ((t.innerHTML = ''), t.appendChild(e))
                : (t.textContent = e.textContent)))
            : void (this.config.html
              ? (this.config.sanitize &&
                    (e = Se(e, this.config.allowList, this.config.sanitizeFn)),
                (t.innerHTML = e))
              : (t.textContent = e))
        }
      }),
      (r.getTitle = function () {
        let t = this._element.getAttribute('data-bs-original-title')
        return (
          t ||
            (t =
              typeof this.config.title === 'function'
                ? this.config.title.call(this._element)
                : this.config.title),
          t
        )
      }),
      (r.updateAttachment = function (t) {
        return t === 'right' ? 'end' : t === 'left' ? 'start' : t
      }),
      (r._getPopperConfig = function (t) {
        const e = this
        const i = { name: 'flip', options: { altBoundary: !0 } }
        return (
          this.config.fallbackPlacements &&
            (i.options.fallbackPlacements = this.config.fallbackPlacements),
          n(
            {},
            {
              placement: t,
              modifiers: [
                i,
                {
                  name: 'preventOverflow',
                  options: { rootBoundary: this.config.boundary }
                },
                {
                  name: 'arrow',
                  options: {
                    element: '.' + this.constructor.NAME + '-arrow'
                  }
                },
                {
                  name: 'onChange',
                  enabled: !0,
                  phase: 'afterWrite',
                  fn: function (t) {
                    return e._handlePopperPlacementChange(t)
                  }
                }
              ],
              onFirstUpdate: function (t) {
                t.options.placement !== t.placement &&
                  e._handlePopperPlacementChange(t)
              }
            },
            this.config.popperConfig
          )
        )
      }),
      (r._addAttachmentClass = function (t) {
        this.getTipElement().classList.add(
          'bs-tooltip-' + this.updateAttachment(t)
        )
      }),
      (r._getContainer = function () {
        return !1 === this.config.container
          ? document.body
          : d(this.config.container)
            ? this.config.container
            : q.findOne(this.config.container)
      }),
      (r._getAttachment = function (t) {
        return Me[t.toUpperCase()]
      }),
      (r._setListeners = function () {
        const t = this
        this.config.trigger.split(' ').forEach(function (e) {
          if (e === 'click') {
            H.on(
              t._element,
              t.constructor.Event.CLICK,
              t.config.selector,
              function (e) {
                return t.toggle(e)
              }
            )
          } else if (e !== 'manual') {
            const n =
              e === 'hover'
                ? t.constructor.Event.MOUSEENTER
                : t.constructor.Event.FOCUSIN
            const i =
              e === 'hover'
                ? t.constructor.Event.MOUSELEAVE
                : t.constructor.Event.FOCUSOUT
            H.on(t._element, n, t.config.selector, function (e) {
              return t._enter(e)
            }),
            H.on(t._element, i, t.config.selector, function (e) {
              return t._leave(e)
            })
          }
        }),
        (this._hideModalHandler = function () {
          t._element && t.hide()
        }),
        H.on(
          this._element.closest('.modal'),
          'hide.bs.modal',
          this._hideModalHandler
        ),
        this.config.selector
          ? (this.config = n({}, this.config, {
              trigger: 'manual',
              selector: ''
            }))
          : this._fixTitle()
      }),
      (r._fixTitle = function () {
        const t = this._element.getAttribute('title')
        const e = typeof this._element.getAttribute('data-bs-original-title');
        (t || e !== 'string') &&
          (this._element.setAttribute('data-bs-original-title', t || ''),
          !t ||
            this._element.getAttribute('aria-label') ||
            this._element.textContent ||
            this._element.setAttribute('aria-label', t),
          this._element.setAttribute('title', ''))
      }),
      (r._enter = function (t, e) {
        const n = this.constructor.DATA_KEY;
        (e = e || T(t.delegateTarget, n)) ||
          ((e = new this.constructor(
            t.delegateTarget,
            this._getDelegateConfig()
          )),
          E(t.delegateTarget, n, e)),
        t &&
            (e._activeTrigger[t.type === 'focusin' ? 'focus' : 'hover'] = !0),
        e.getTipElement().classList.contains('show') ||
          e._hoverState === 'show'
          ? (e._hoverState = 'show')
          : (clearTimeout(e._timeout),
            (e._hoverState = 'show'),
            e.config.delay && e.config.delay.show
              ? (e._timeout = setTimeout(function () {
                  e._hoverState === 'show' && e.show()
                }, e.config.delay.show))
              : e.show())
      }),
      (r._leave = function (t, e) {
        const n = this.constructor.DATA_KEY;
        (e = e || T(t.delegateTarget, n)) ||
          ((e = new this.constructor(
            t.delegateTarget,
            this._getDelegateConfig()
          )),
          E(t.delegateTarget, n, e)),
        t &&
            (e._activeTrigger[t.type === 'focusout' ? 'focus' : 'hover'] = !1),
        e._isWithActiveTrigger() ||
            (clearTimeout(e._timeout),
            (e._hoverState = 'out'),
            e.config.delay && e.config.delay.hide
              ? (e._timeout = setTimeout(function () {
                  e._hoverState === 'out' && e.hide()
                }, e.config.delay.hide))
              : e.hide())
      }),
      (r._isWithActiveTrigger = function () {
        for (const t in this._activeTrigger) {
          if (this._activeTrigger[t]) return !0
        }
        return !1
      }),
      (r._getConfig = function (t) {
        const e = Y.getDataAttributes(this._element)
        return (
          Object.keys(e).forEach(function (t) {
            Ie.has(t) && delete e[t]
          }),
          t &&
            typeof t.container === 'object' &&
            t.container.jquery &&
            (t.container = t.container[0]),
          typeof (t = n(
            {},
            this.constructor.Default,
            e,
            typeof t === 'object' && t ? t : {}
          )).delay === 'number' && (t.delay = { show: t.delay, hide: t.delay }),
          typeof t.title === 'number' && (t.title = t.title.toString()),
          typeof t.content === 'number' && (t.content = t.content.toString()),
          p(je, t, this.constructor.DefaultType),
          t.sanitize &&
            (t.template = Se(t.template, t.allowList, t.sanitizeFn)),
          t
        )
      }),
      (r._getDelegateConfig = function () {
        const t = {}
        if (this.config) {
          for (const e in this.config) {
            this.constructor.Default[e] !== this.config[e] &&
              (t[e] = this.config[e])
          }
        }
        return t
      }),
      (r._cleanTipClass = function () {
        const t = this.getTipElement()
        const e = t.getAttribute('class').match(Ne)
        e !== null &&
          e.length > 0 &&
          e
            .map(function (t) {
              return t.trim()
            })
            .forEach(function (e) {
              return t.classList.remove(e)
            })
      }),
      (r._handlePopperPlacementChange = function (t) {
        const e = t.state
        e &&
          ((this.tip = e.elements.popper),
          this._cleanTipClass(),
          this._addAttachmentClass(this._getAttachment(e.placement)))
      }),
      (o.jQueryInterface = function (t) {
        return this.each(function () {
          let e = T(this, 'bs.tooltip')
          const n = typeof t === 'object' && t
          if (
            (e || !/dispose|hide/.test(t)) &&
            (e || (e = new o(this, n)), typeof t === 'string')
          ) {
            if (void 0 === e[t]) {
              throw new TypeError('No method named "' + t + '"')
            }
            e[t]()
          }
        })
      }),
      e(o, null, [
        {
          key: 'Default',
          get: function () {
            return Be
          }
        },
        {
          key: 'NAME',
          get: function () {
            return je
          }
        },
        {
          key: 'DATA_KEY',
          get: function () {
            return 'bs.tooltip'
          }
        },
        {
          key: 'Event',
          get: function () {
            return He
          }
        },
        {
          key: 'EVENT_KEY',
          get: function () {
            return '.bs.tooltip'
          }
        },
        {
          key: 'DefaultType',
          get: function () {
            return Pe
          }
        }
      ]),
      o
    )
  })(R)
  b(function () {
    const t = _()
    if (t) {
      const e = t.fn[je];
      (t.fn[je] = Re.jQueryInterface),
      (t.fn[je].Constructor = Re),
      (t.fn[je].noConflict = function () {
        return (t.fn[je] = e), Re.jQueryInterface
      })
    }
  })
  const We = 'popover'
  const Ke = new RegExp('(^|\\s)bs-popover\\S+', 'g')
  const Qe = n({}, Re.Default, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template:
      '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
  })
  const Ue = n({}, Re.DefaultType, { content: '(string|element|function)' })
  const Fe = {
    HIDE: 'hide.bs.popover',
    HIDDEN: 'hidden.bs.popover',
    SHOW: 'show.bs.popover',
    SHOWN: 'shown.bs.popover',
    INSERTED: 'inserted.bs.popover',
    CLICK: 'click.bs.popover',
    FOCUSIN: 'focusin.bs.popover',
    FOCUSOUT: 'focusout.bs.popover',
    MOUSEENTER: 'mouseenter.bs.popover',
    MOUSELEAVE: 'mouseleave.bs.popover'
  }
  const Ye = (function (t) {
    function n () {
      return t.apply(this, arguments) || this
    }
    i(n, t)
    const o = n.prototype
    return (
      (o.isWithContent = function () {
        return this.getTitle() || this._getContent()
      }),
      (o.setContent = function () {
        const t = this.getTipElement()
        this.setElementContent(
          q.findOne('.popover-header', t),
          this.getTitle()
        )
        let e = this._getContent()
        typeof e === 'function' && (e = e.call(this._element)),
        this.setElementContent(q.findOne('.popover-body', t), e),
        t.classList.remove('fade', 'show')
      }),
      (o._addAttachmentClass = function (t) {
        this.getTipElement().classList.add(
          'bs-popover-' + this.updateAttachment(t)
        )
      }),
      (o._getContent = function () {
        return (
          this._element.getAttribute('data-bs-content') || this.config.content
        )
      }),
      (o._cleanTipClass = function () {
        const t = this.getTipElement()
        const e = t.getAttribute('class').match(Ke)
        e !== null &&
          e.length > 0 &&
          e
            .map(function (t) {
              return t.trim()
            })
            .forEach(function (e) {
              return t.classList.remove(e)
            })
      }),
      (n.jQueryInterface = function (t) {
        return this.each(function () {
          let e = T(this, 'bs.popover')
          const i = typeof t === 'object' ? t : null
          if (
            (e || !/dispose|hide/.test(t)) &&
            (e || ((e = new n(this, i)), E(this, 'bs.popover', e)),
            typeof t === 'string')
          ) {
            if (void 0 === e[t]) {
              throw new TypeError('No method named "' + t + '"')
            }
            e[t]()
          }
        })
      }),
      e(n, null, [
        {
          key: 'Default',
          get: function () {
            return Qe
          }
        },
        {
          key: 'NAME',
          get: function () {
            return We
          }
        },
        {
          key: 'DATA_KEY',
          get: function () {
            return 'bs.popover'
          }
        },
        {
          key: 'Event',
          get: function () {
            return Fe
          }
        },
        {
          key: 'EVENT_KEY',
          get: function () {
            return '.bs.popover'
          }
        },
        {
          key: 'DefaultType',
          get: function () {
            return Ue
          }
        }
      ]),
      n
    )
  })(Re)
  b(function () {
    const t = _()
    if (t) {
      const e = t.fn[We];
      (t.fn[We] = Ye.jQueryInterface),
      (t.fn[We].Constructor = Ye),
      (t.fn[We].noConflict = function () {
        return (t.fn[We] = e), Ye.jQueryInterface
      })
    }
  })
  const qe = 'scrollspy'
  const ze = { offset: 10, method: 'auto', target: '' }
  const Ve = { offset: 'number', method: 'string', target: '(string|element)' }
  const Xe = (function (t) {
    function o (e, n) {
      let i
      return (
        ((i = t.call(this, e) || this)._scrollElement =
          e.tagName === 'BODY' ? window : e),
        (i._config = i._getConfig(n)),
        (i._selector =
          i._config.target +
          ' .nav-link, ' +
          i._config.target +
          ' .list-group-item, ' +
          i._config.target +
          ' .dropdown-item'),
        (i._offsets = []),
        (i._targets = []),
        (i._activeTarget = null),
        (i._scrollHeight = 0),
        H.on(i._scrollElement, 'scroll.bs.scrollspy', function (t) {
          return i._process(t)
        }),
        i.refresh(),
        i._process(),
        i
      )
    }
    i(o, t)
    const r = o.prototype
    return (
      (r.refresh = function () {
        const t = this
        const e =
          this._scrollElement === this._scrollElement.window
            ? 'offset'
            : 'position'
        const n = this._config.method === 'auto' ? e : this._config.method
        const i = n === 'position' ? this._getScrollTop() : 0;
        (this._offsets = []),
        (this._targets = []),
        (this._scrollHeight = this._getScrollHeight()),
        q
          .find(this._selector)
          .map(function (t) {
            const e = l(t)
            const o = e ? q.findOne(e) : null
            if (o) {
              const r = o.getBoundingClientRect()
              if (r.width || r.height) return [Y[n](o).top + i, e]
            }
            return null
          })
          .filter(function (t) {
            return t
          })
          .sort(function (t, e) {
            return t[0] - e[0]
          })
          .forEach(function (e) {
            t._offsets.push(e[0]), t._targets.push(e[1])
          })
      }),
      (r.dispose = function () {
        t.prototype.dispose.call(this),
        H.off(this._scrollElement, '.bs.scrollspy'),
        (this._scrollElement = null),
        (this._config = null),
        (this._selector = null),
        (this._offsets = null),
        (this._targets = null),
        (this._activeTarget = null),
        (this._scrollHeight = null)
      }),
      (r._getConfig = function (t) {
        if (
          typeof (t = n({}, ze, typeof t === 'object' && t ? t : {})).target !==
            'string' &&
          d(t.target)
        ) {
          let e = t.target.id
          e || ((e = s(qe)), (t.target.id = e)), (t.target = '#' + e)
        }
        return p(qe, t, Ve), t
      }),
      (r._getScrollTop = function () {
        return this._scrollElement === window
          ? this._scrollElement.pageYOffset
          : this._scrollElement.scrollTop
      }),
      (r._getScrollHeight = function () {
        return (
          this._scrollElement.scrollHeight ||
          Math.max(
            document.body.scrollHeight,
            document.documentElement.scrollHeight
          )
        )
      }),
      (r._getOffsetHeight = function () {
        return this._scrollElement === window
          ? window.innerHeight
          : this._scrollElement.getBoundingClientRect().height
      }),
      (r._process = function () {
        const t = this._getScrollTop() + this._config.offset
        const e = this._getScrollHeight()
        const n = this._config.offset + e - this._getOffsetHeight()
        if ((this._scrollHeight !== e && this.refresh(), t >= n)) {
          const i = this._targets[this._targets.length - 1]
          this._activeTarget !== i && this._activate(i)
        } else {
          if (
            this._activeTarget &&
            t < this._offsets[0] &&
            this._offsets[0] > 0
          ) {
            return (this._activeTarget = null), void this._clear()
          }
          for (let o = this._offsets.length; o--;) {
            this._activeTarget !== this._targets[o] &&
              t >= this._offsets[o] &&
              (void 0 === this._offsets[o + 1] || t < this._offsets[o + 1]) &&
              this._activate(this._targets[o])
          }
        }
      }),
      (r._activate = function (t) {
        (this._activeTarget = t), this._clear()
        const e = this._selector.split(',').map(function (e) {
          return e + '[data-bs-target="' + t + '"],' + e + '[href="' + t + '"]'
        })
        const n = q.findOne(e.join(','))
        n.classList.contains('dropdown-item')
          ? (q
              .findOne('.dropdown-toggle', n.closest('.dropdown'))
              .classList.add('active'),
            n.classList.add('active'))
          : (n.classList.add('active'),
            q.parents(n, '.nav, .list-group').forEach(function (t) {
              q.prev(t, '.nav-link, .list-group-item').forEach(function (t) {
                return t.classList.add('active')
              }),
              q.prev(t, '.nav-item').forEach(function (t) {
                q.children(t, '.nav-link').forEach(function (t) {
                  return t.classList.add('active')
                })
              })
            })),
        H.trigger(this._scrollElement, 'activate.bs.scrollspy', {
          relatedTarget: t
        })
      }),
      (r._clear = function () {
        q.find(this._selector)
          .filter(function (t) {
            return t.classList.contains('active')
          })
          .forEach(function (t) {
            return t.classList.remove('active')
          })
      }),
      (o.jQueryInterface = function (t) {
        return this.each(function () {
          let e = T(this, 'bs.scrollspy')
          if (
            (e || (e = new o(this, typeof t === 'object' && t)),
            typeof t === 'string')
          ) {
            if (void 0 === e[t]) {
              throw new TypeError('No method named "' + t + '"')
            }
            e[t]()
          }
        })
      }),
      e(o, null, [
        {
          key: 'Default',
          get: function () {
            return ze
          }
        },
        {
          key: 'DATA_KEY',
          get: function () {
            return 'bs.scrollspy'
          }
        }
      ]),
      o
    )
  })(R)
  H.on(window, 'load.bs.scrollspy.data-api', function () {
    q.find('[data-bs-spy="scroll"]').forEach(function (t) {
      return new Xe(t, Y.getDataAttributes(t))
    })
  }),
  b(function () {
    const t = _()
    if (t) {
      const e = t.fn[qe];
      (t.fn[qe] = Xe.jQueryInterface),
      (t.fn[qe].Constructor = Xe),
      (t.fn[qe].noConflict = function () {
        return (t.fn[qe] = e), Xe.jQueryInterface
      })
    }
  })
  const $e = (function (t) {
    function n () {
      return t.apply(this, arguments) || this
    }
    i(n, t)
    const o = n.prototype
    return (
      (o.show = function () {
        const t = this
        if (
          !(
            (this._element.parentNode &&
              this._element.parentNode.nodeType === Node.ELEMENT_NODE &&
              this._element.classList.contains('active')) ||
            this._element.classList.contains('disabled')
          )
        ) {
          let e
          const n = c(this._element)
          const i = this._element.closest('.nav, .list-group')
          if (i) {
            const o =
              i.nodeName === 'UL' || i.nodeName === 'OL'
                ? ':scope > li > .active'
                : '.active'
            e = (e = q.find(o, i))[e.length - 1]
          }
          let r = null
          if (
            (e &&
              (r = H.trigger(e, 'hide.bs.tab', {
                relatedTarget: this._element
              })),
            !(
              H.trigger(this._element, 'show.bs.tab', { relatedTarget: e })
                .defaultPrevented ||
              (r !== null && r.defaultPrevented)
            ))
          ) {
            this._activate(this._element, i)
            const s = function () {
              H.trigger(e, 'hidden.bs.tab', { relatedTarget: t._element }),
              H.trigger(t._element, 'shown.bs.tab', { relatedTarget: e })
            }
            n ? this._activate(n, n.parentNode, s) : s()
          }
        }
      }),
      (o._activate = function (t, e, n) {
        const i = this
        const o = (
          !e || (e.nodeName !== 'UL' && e.nodeName !== 'OL')
            ? q.children(e, '.active')
            : q.find(':scope > li > .active', e)
        )[0]
        const r = n && o && o.classList.contains('fade')
        const s = function () {
          return i._transitionComplete(t, o, n)
        }
        if (o && r) {
          const a = u(o)
          o.classList.remove('show'), H.one(o, 'transitionend', s), h(o, a)
        } else s()
      }),
      (o._transitionComplete = function (t, e, n) {
        if (e) {
          e.classList.remove('active')
          const i = q.findOne(':scope > .dropdown-menu .active', e.parentNode)
          i && i.classList.remove('active'),
          e.getAttribute('role') === 'tab' &&
              e.setAttribute('aria-selected', !1)
        }
        (t.classList.add('active'),
        t.getAttribute('role') === 'tab' && t.setAttribute('aria-selected', !0),
        v(t),
        t.classList.contains('fade') && t.classList.add('show'),
        t.parentNode && t.parentNode.classList.contains('dropdown-menu')) &&
          (t.closest('.dropdown') &&
            q.find('.dropdown-toggle').forEach(function (t) {
              return t.classList.add('active')
            }),
          t.setAttribute('aria-expanded', !0))
        n && n()
      }),
      (n.jQueryInterface = function (t) {
        return this.each(function () {
          const e = T(this, 'bs.tab') || new n(this)
          if (typeof t === 'string') {
            if (void 0 === e[t]) {
              throw new TypeError('No method named "' + t + '"')
            }
            e[t]()
          }
        })
      }),
      e(n, null, [
        {
          key: 'DATA_KEY',
          get: function () {
            return 'bs.tab'
          }
        }
      ]),
      n
    )
  })(R)
  H.on(
    document,
    'click.bs.tab.data-api',
    '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
    function (t) {
      t.preventDefault(), (T(this, 'bs.tab') || new $e(this)).show()
    }
  ),
  b(function () {
    const t = _()
    if (t) {
      const e = t.fn.tab;
      (t.fn.tab = $e.jQueryInterface),
      (t.fn.tab.Constructor = $e),
      (t.fn.tab.noConflict = function () {
        return (t.fn.tab = e), $e.jQueryInterface
      })
    }
  })
  const Ge = { animation: 'boolean', autohide: 'boolean', delay: 'number' }
  const Ze = { animation: !0, autohide: !0, delay: 5e3 }
  const Je = (function (t) {
    function o (e, n) {
      let i
      return (
        ((i = t.call(this, e) || this)._config = i._getConfig(n)),
        (i._timeout = null),
        i._setListeners(),
        i
      )
    }
    i(o, t)
    const r = o.prototype
    return (
      (r.show = function () {
        const t = this
        if (!H.trigger(this._element, 'show.bs.toast').defaultPrevented) {
          this._clearTimeout(),
          this._config.animation && this._element.classList.add('fade')
          const e = function () {
            t._element.classList.remove('showing'),
            t._element.classList.add('show'),
            H.trigger(t._element, 'shown.bs.toast'),
            t._config.autohide &&
                (t._timeout = setTimeout(function () {
                  t.hide()
                }, t._config.delay))
          }
          if (
            (this._element.classList.remove('hide'),
            v(this._element),
            this._element.classList.add('showing'),
            this._config.animation)
          ) {
            const n = u(this._element)
            H.one(this._element, 'transitionend', e), h(this._element, n)
          } else e()
        }
      }),
      (r.hide = function () {
        const t = this
        if (
          this._element.classList.contains('show') &&
          !H.trigger(this._element, 'hide.bs.toast').defaultPrevented
        ) {
          const e = function () {
            t._element.classList.add('hide'),
            H.trigger(t._element, 'hidden.bs.toast')
          }
          if (
            (this._element.classList.remove('show'), this._config.animation)
          ) {
            const n = u(this._element)
            H.one(this._element, 'transitionend', e), h(this._element, n)
          } else e()
        }
      }),
      (r.dispose = function () {
        this._clearTimeout(),
        this._element.classList.contains('show') &&
            this._element.classList.remove('show'),
        H.off(this._element, 'click.dismiss.bs.toast'),
        t.prototype.dispose.call(this),
        (this._config = null)
      }),
      (r._getConfig = function (t) {
        return (
          (t = n(
            {},
            Ze,
            Y.getDataAttributes(this._element),
            typeof t === 'object' && t ? t : {}
          )),
          p('toast', t, this.constructor.DefaultType),
          t
        )
      }),
      (r._setListeners = function () {
        const t = this
        H.on(
          this._element,
          'click.dismiss.bs.toast',
          '[data-bs-dismiss="toast"]',
          function () {
            return t.hide()
          }
        )
      }),
      (r._clearTimeout = function () {
        clearTimeout(this._timeout), (this._timeout = null)
      }),
      (o.jQueryInterface = function (t) {
        return this.each(function () {
          let e = T(this, 'bs.toast')
          if (
            (e || (e = new o(this, typeof t === 'object' && t)),
            typeof t === 'string')
          ) {
            if (void 0 === e[t]) {
              throw new TypeError('No method named "' + t + '"')
            }
            e[t](this)
          }
        })
      }),
      e(o, null, [
        {
          key: 'DefaultType',
          get: function () {
            return Ge
          }
        },
        {
          key: 'Default',
          get: function () {
            return Ze
          }
        },
        {
          key: 'DATA_KEY',
          get: function () {
            return 'bs.toast'
          }
        }
      ]),
      o
    )
  })(R)
  return (
    b(function () {
      const t = _()
      if (t) {
        const e = t.fn.toast;
        (t.fn.toast = Je.jQueryInterface),
        (t.fn.toast.Constructor = Je),
        (t.fn.toast.noConflict = function () {
          return (t.fn.toast = e), Je.jQueryInterface
        })
      }
    }),
    {
      Alert: K,
      Button: Q,
      Carousel: Z,
      Collapse: nt,
      Dropdown: Te,
      Modal: Le,
      Popover: Ye,
      ScrollSpy: Xe,
      Tab: $e,
      Toast: Je,
      Tooltip: Re
    }
  )
})
// # sourceMappingURL=bootstrap.bundle.min.js.map
